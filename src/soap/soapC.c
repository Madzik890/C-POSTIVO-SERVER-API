/* soapC.c
   Generated by gSOAP 2.7.13 from postivoService.h
   Copyright(C) 2000-2009, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

#ifdef __cplusplus
extern "C" {
#endif

SOAP_SOURCE_STAMP("@(#) soapC.c ver 2.7.13 2011-02-27 12:25:09 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (!soap->header)
	{	soap->header = (struct SOAP_ENV__Header*)soap_malloc(soap, sizeof(struct SOAP_ENV__Header));
		soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = (struct SOAP_ENV__Fault*)soap_malloc(soap, sizeof(struct SOAP_ENV__Fault));
		if (!soap->fault)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = (struct SOAP_ENV__Reason*)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason));
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	for (;;)
		if (!soap_getelement(soap, &t))
			if (soap->error || soap_ignore_element(soap))
				break;
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_float:
		return soap_in_float(soap, NULL, NULL, "xsd:float");
	case SOAP_TYPE_xsd__boolean:
		return soap_in_xsd__boolean(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_ns2__removeSender:
		return soap_in_ns2__removeSender(soap, NULL, NULL, "ns2:removeSender");
	case SOAP_TYPE_ns2__removeSenderResponse:
		return soap_in_ns2__removeSenderResponse(soap, NULL, NULL, "ns2:removeSenderResponse");
	case SOAP_TYPE_ns2__verifySender:
		return soap_in_ns2__verifySender(soap, NULL, NULL, "ns2:verifySender");
	case SOAP_TYPE_ns2__verifySenderResponse:
		return soap_in_ns2__verifySenderResponse(soap, NULL, NULL, "ns2:verifySenderResponse");
	case SOAP_TYPE_ns2__addSender:
		return soap_in_ns2__addSender(soap, NULL, NULL, "ns2:addSender");
	case SOAP_TYPE_ns2__addSenderResponse:
		return soap_in_ns2__addSenderResponse(soap, NULL, NULL, "ns2:addSenderResponse");
	case SOAP_TYPE_ns2__getPrice:
		return soap_in_ns2__getPrice(soap, NULL, NULL, "ns2:getPrice");
	case SOAP_TYPE_ns2__getPriceResponse:
		return soap_in_ns2__getPriceResponse(soap, NULL, NULL, "ns2:getPriceResponse");
	case SOAP_TYPE_ns2__getCertificate:
		return soap_in_ns2__getCertificate(soap, NULL, NULL, "ns2:getCertificate");
	case SOAP_TYPE_ns2__getCertificateResponse:
		return soap_in_ns2__getCertificateResponse(soap, NULL, NULL, "ns2:getCertificateResponse");
	case SOAP_TYPE_ns2__getSenders:
		return soap_in_ns2__getSenders(soap, NULL, NULL, "ns2:getSenders");
	case SOAP_TYPE_ns2__getSendersResponse:
		return soap_in_ns2__getSendersResponse(soap, NULL, NULL, "ns2:getSendersResponse");
	case SOAP_TYPE_ns2__getConfigProfiles:
		return soap_in_ns2__getConfigProfiles(soap, NULL, NULL, "ns2:getConfigProfiles");
	case SOAP_TYPE_ns2__getConfigProfilesResponse:
		return soap_in_ns2__getConfigProfilesResponse(soap, NULL, NULL, "ns2:getConfigProfilesResponse");
	case SOAP_TYPE_ns2__getBalance:
		return soap_in_ns2__getBalance(soap, NULL, NULL, "ns2:getBalance");
	case SOAP_TYPE_ns2__getBalanceResponse:
		return soap_in_ns2__getBalanceResponse(soap, NULL, NULL, "ns2:getBalanceResponse");
	case SOAP_TYPE_ns2__getDispatchStatus:
		return soap_in_ns2__getDispatchStatus(soap, NULL, NULL, "ns2:getDispatchStatus");
	case SOAP_TYPE_ns2__getDispatchStatusResponse:
		return soap_in_ns2__getDispatchStatusResponse(soap, NULL, NULL, "ns2:getDispatchStatusResponse");
	case SOAP_TYPE_ns2__dispatch:
		return soap_in_ns2__dispatch(soap, NULL, NULL, "ns2:dispatch");
	case SOAP_TYPE_ns2__dispatchResponse:
		return soap_in_ns2__dispatchResponse(soap, NULL, NULL, "ns2:dispatchResponse");
	case SOAP_TYPE_ArrayOfDispatchIds:
		return soap_in_ArrayOfDispatchIds(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_ArrayOfOptions:
		return soap_in_ArrayOfOptions(soap, NULL, NULL, "ns1:Option");
	case SOAP_TYPE_ArrayOfRecipients:
		return soap_in_ArrayOfRecipients(soap, NULL, NULL, "ns1:Recipient");
	case SOAP_TYPE_ArrayOfDocumentFiles:
		return soap_in_ArrayOfDocumentFiles(soap, NULL, NULL, "ns1:DocumentFile");
	case SOAP_TYPE_ns1__RemoveSenderReturnObject:
		return soap_in_ns1__RemoveSenderReturnObject(soap, NULL, NULL, "ns1:RemoveSenderReturnObject");
	case SOAP_TYPE_ns1__VerifySenderReturnObject:
		return soap_in_ns1__VerifySenderReturnObject(soap, NULL, NULL, "ns1:VerifySenderReturnObject");
	case SOAP_TYPE_ns1__AddSenderReturnObject:
		return soap_in_ns1__AddSenderReturnObject(soap, NULL, NULL, "ns1:AddSenderReturnObject");
	case SOAP_TYPE_ArrayOfShipmentsPrice:
		return soap_in_ArrayOfShipmentsPrice(soap, NULL, NULL, "ns1:ShipmentPrice");
	case SOAP_TYPE_ns1__PriceReturnObject:
		return soap_in_ns1__PriceReturnObject(soap, NULL, NULL, "ns1:PriceReturnObject");
	case SOAP_TYPE_ns1__CertificateReturnObject:
		return soap_in_ns1__CertificateReturnObject(soap, NULL, NULL, "ns1:CertificateReturnObject");
	case SOAP_TYPE_ArrayOfSenders:
		return soap_in_ArrayOfSenders(soap, NULL, NULL, "ns1:Sender");
	case SOAP_TYPE_ns1__SendersReturnObject:
		return soap_in_ns1__SendersReturnObject(soap, NULL, NULL, "ns1:SendersReturnObject");
	case SOAP_TYPE_ArrayOfConfigProfiles:
		return soap_in_ArrayOfConfigProfiles(soap, NULL, NULL, "ns1:ConfigProfile");
	case SOAP_TYPE_ns1__ConfigProfilesReturnObject:
		return soap_in_ns1__ConfigProfilesReturnObject(soap, NULL, NULL, "ns1:ConfigProfilesReturnObject");
	case SOAP_TYPE_ns1__BalanceReturnObject:
		return soap_in_ns1__BalanceReturnObject(soap, NULL, NULL, "ns1:BalanceReturnObject");
	case SOAP_TYPE_ArrayOfShipments:
		return soap_in_ArrayOfShipments(soap, NULL, NULL, "ns1:Shipment");
	case SOAP_TYPE_ns1__DispatchReturnObject:
		return soap_in_ns1__DispatchReturnObject(soap, NULL, NULL, "ns1:DispatchReturnObject");
	case SOAP_TYPE_ns1__SenderData:
		return soap_in_ns1__SenderData(soap, NULL, NULL, "ns1:SenderData");
	case SOAP_TYPE_ns1__ShipmentPrice:
		return soap_in_ns1__ShipmentPrice(soap, NULL, NULL, "ns1:ShipmentPrice");
	case SOAP_TYPE_ns1__Sender:
		return soap_in_ns1__Sender(soap, NULL, NULL, "ns1:Sender");
	case SOAP_TYPE_ns1__ConfigProfile:
		return soap_in_ns1__ConfigProfile(soap, NULL, NULL, "ns1:ConfigProfile");
	case SOAP_TYPE_ns1__Shipment:
		return soap_in_ns1__Shipment(soap, NULL, NULL, "ns1:Shipment");
	case SOAP_TYPE_ns1__Option:
		return soap_in_ns1__Option(soap, NULL, NULL, "ns1:Option");
	case SOAP_TYPE_ns1__Recipient:
		return soap_in_ns1__Recipient(soap, NULL, NULL, "ns1:Recipient");
	case SOAP_TYPE_ns1__DocumentFile:
		return soap_in_ns1__DocumentFile(soap, NULL, NULL, "ns1:DocumentFile");
	case SOAP_TYPE_PointerTons2__removeSenderResponse:
		return soap_in_PointerTons2__removeSenderResponse(soap, NULL, NULL, "ns2:removeSenderResponse");
	case SOAP_TYPE_PointerTons1__RemoveSenderReturnObject:
		return soap_in_PointerTons1__RemoveSenderReturnObject(soap, NULL, NULL, "ns1:RemoveSenderReturnObject");
	case SOAP_TYPE_PointerTons2__verifySenderResponse:
		return soap_in_PointerTons2__verifySenderResponse(soap, NULL, NULL, "ns2:verifySenderResponse");
	case SOAP_TYPE_PointerTons1__VerifySenderReturnObject:
		return soap_in_PointerTons1__VerifySenderReturnObject(soap, NULL, NULL, "ns1:VerifySenderReturnObject");
	case SOAP_TYPE_PointerTons2__addSenderResponse:
		return soap_in_PointerTons2__addSenderResponse(soap, NULL, NULL, "ns2:addSenderResponse");
	case SOAP_TYPE_PointerTons1__SenderData:
		return soap_in_PointerTons1__SenderData(soap, NULL, NULL, "ns1:SenderData");
	case SOAP_TYPE_PointerTons1__AddSenderReturnObject:
		return soap_in_PointerTons1__AddSenderReturnObject(soap, NULL, NULL, "ns1:AddSenderReturnObject");
	case SOAP_TYPE_PointerTons2__getPriceResponse:
		return soap_in_PointerTons2__getPriceResponse(soap, NULL, NULL, "ns2:getPriceResponse");
	case SOAP_TYPE_PointerTons1__PriceReturnObject:
		return soap_in_PointerTons1__PriceReturnObject(soap, NULL, NULL, "ns1:PriceReturnObject");
	case SOAP_TYPE_PointerTons2__getCertificateResponse:
		return soap_in_PointerTons2__getCertificateResponse(soap, NULL, NULL, "ns2:getCertificateResponse");
	case SOAP_TYPE_PointerTons1__CertificateReturnObject:
		return soap_in_PointerTons1__CertificateReturnObject(soap, NULL, NULL, "ns1:CertificateReturnObject");
	case SOAP_TYPE_PointerTons2__getSendersResponse:
		return soap_in_PointerTons2__getSendersResponse(soap, NULL, NULL, "ns2:getSendersResponse");
	case SOAP_TYPE_PointerTons1__SendersReturnObject:
		return soap_in_PointerTons1__SendersReturnObject(soap, NULL, NULL, "ns1:SendersReturnObject");
	case SOAP_TYPE_PointerTons2__getConfigProfilesResponse:
		return soap_in_PointerTons2__getConfigProfilesResponse(soap, NULL, NULL, "ns2:getConfigProfilesResponse");
	case SOAP_TYPE_PointerTons1__ConfigProfilesReturnObject:
		return soap_in_PointerTons1__ConfigProfilesReturnObject(soap, NULL, NULL, "ns1:ConfigProfilesReturnObject");
	case SOAP_TYPE_PointerTons2__getBalanceResponse:
		return soap_in_PointerTons2__getBalanceResponse(soap, NULL, NULL, "ns2:getBalanceResponse");
	case SOAP_TYPE_PointerTons1__BalanceReturnObject:
		return soap_in_PointerTons1__BalanceReturnObject(soap, NULL, NULL, "ns1:BalanceReturnObject");
	case SOAP_TYPE_PointerTons2__getDispatchStatusResponse:
		return soap_in_PointerTons2__getDispatchStatusResponse(soap, NULL, NULL, "ns2:getDispatchStatusResponse");
	case SOAP_TYPE_PointerToArrayOfDispatchIds:
		return soap_in_PointerToArrayOfDispatchIds(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerTons2__dispatchResponse:
		return soap_in_PointerTons2__dispatchResponse(soap, NULL, NULL, "ns2:dispatchResponse");
	case SOAP_TYPE_PointerToArrayOfOptions:
		return soap_in_PointerToArrayOfOptions(soap, NULL, NULL, "ns1:Option");
	case SOAP_TYPE_PointerToArrayOfRecipients:
		return soap_in_PointerToArrayOfRecipients(soap, NULL, NULL, "ns1:Recipient");
	case SOAP_TYPE_PointerToArrayOfDocumentFiles:
		return soap_in_PointerToArrayOfDocumentFiles(soap, NULL, NULL, "ns1:DocumentFile");
	case SOAP_TYPE_PointerTons1__DispatchReturnObject:
		return soap_in_PointerTons1__DispatchReturnObject(soap, NULL, NULL, "ns1:DispatchReturnObject");
	case SOAP_TYPE_PointerToPointerTons1__ShipmentPrice:
		return soap_in_PointerToPointerTons1__ShipmentPrice(soap, NULL, NULL, "ns1:ShipmentPrice");
	case SOAP_TYPE_PointerTons1__ShipmentPrice:
		return soap_in_PointerTons1__ShipmentPrice(soap, NULL, NULL, "ns1:ShipmentPrice");
	case SOAP_TYPE_PointerToPointerTons1__Sender:
		return soap_in_PointerToPointerTons1__Sender(soap, NULL, NULL, "ns1:Sender");
	case SOAP_TYPE_PointerTons1__Sender:
		return soap_in_PointerTons1__Sender(soap, NULL, NULL, "ns1:Sender");
	case SOAP_TYPE_PointerToPointerTons1__ConfigProfile:
		return soap_in_PointerToPointerTons1__ConfigProfile(soap, NULL, NULL, "ns1:ConfigProfile");
	case SOAP_TYPE_PointerTons1__ConfigProfile:
		return soap_in_PointerTons1__ConfigProfile(soap, NULL, NULL, "ns1:ConfigProfile");
	case SOAP_TYPE_PointerTostring:
		return soap_in_PointerTostring(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerToPointerTons1__Shipment:
		return soap_in_PointerToPointerTons1__Shipment(soap, NULL, NULL, "ns1:Shipment");
	case SOAP_TYPE_PointerTons1__Shipment:
		return soap_in_PointerTons1__Shipment(soap, NULL, NULL, "ns1:Shipment");
	case SOAP_TYPE_PointerToPointerTons1__Option:
		return soap_in_PointerToPointerTons1__Option(soap, NULL, NULL, "ns1:Option");
	case SOAP_TYPE_PointerTons1__Option:
		return soap_in_PointerTons1__Option(soap, NULL, NULL, "ns1:Option");
	case SOAP_TYPE_PointerToPointerTons1__Recipient:
		return soap_in_PointerToPointerTons1__Recipient(soap, NULL, NULL, "ns1:Recipient");
	case SOAP_TYPE_PointerTons1__Recipient:
		return soap_in_PointerTons1__Recipient(soap, NULL, NULL, "ns1:Recipient");
	case SOAP_TYPE_PointerToPointerTons1__DocumentFile:
		return soap_in_PointerToPointerTons1__DocumentFile(soap, NULL, NULL, "ns1:DocumentFile");
	case SOAP_TYPE_PointerTons1__DocumentFile:
		return soap_in_PointerTons1__DocumentFile(soap, NULL, NULL, "ns1:DocumentFile");
	case SOAP_TYPE_PointerToArrayOfShipmentsPrice:
		return soap_in_PointerToArrayOfShipmentsPrice(soap, NULL, NULL, "ns1:ShipmentPrice");
	case SOAP_TYPE_PointerToArrayOfSenders:
		return soap_in_PointerToArrayOfSenders(soap, NULL, NULL, "ns1:Sender");
	case SOAP_TYPE_PointerToArrayOfConfigProfiles:
		return soap_in_PointerToArrayOfConfigProfiles(soap, NULL, NULL, "ns1:ConfigProfile");
	case SOAP_TYPE_PointerToArrayOfShipments:
		return soap_in_PointerToArrayOfShipments(soap, NULL, NULL, "ns1:Shipment");
	case SOAP_TYPE_PointerTofloat:
		return soap_in_PointerTofloat(soap, NULL, NULL, "xsd:float");
	case SOAP_TYPE_PointerToint:
		return soap_in_PointerToint(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:float"))
		{	*type = SOAP_TYPE_float;
			return soap_in_float(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_xsd__boolean;
			return soap_in_xsd__boolean(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:removeSender"))
		{	*type = SOAP_TYPE_ns2__removeSender;
			return soap_in_ns2__removeSender(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:removeSenderResponse"))
		{	*type = SOAP_TYPE_ns2__removeSenderResponse;
			return soap_in_ns2__removeSenderResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:verifySender"))
		{	*type = SOAP_TYPE_ns2__verifySender;
			return soap_in_ns2__verifySender(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:verifySenderResponse"))
		{	*type = SOAP_TYPE_ns2__verifySenderResponse;
			return soap_in_ns2__verifySenderResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:addSender"))
		{	*type = SOAP_TYPE_ns2__addSender;
			return soap_in_ns2__addSender(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:addSenderResponse"))
		{	*type = SOAP_TYPE_ns2__addSenderResponse;
			return soap_in_ns2__addSenderResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getPrice"))
		{	*type = SOAP_TYPE_ns2__getPrice;
			return soap_in_ns2__getPrice(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getPriceResponse"))
		{	*type = SOAP_TYPE_ns2__getPriceResponse;
			return soap_in_ns2__getPriceResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getCertificate"))
		{	*type = SOAP_TYPE_ns2__getCertificate;
			return soap_in_ns2__getCertificate(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getCertificateResponse"))
		{	*type = SOAP_TYPE_ns2__getCertificateResponse;
			return soap_in_ns2__getCertificateResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getSenders"))
		{	*type = SOAP_TYPE_ns2__getSenders;
			return soap_in_ns2__getSenders(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getSendersResponse"))
		{	*type = SOAP_TYPE_ns2__getSendersResponse;
			return soap_in_ns2__getSendersResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getConfigProfiles"))
		{	*type = SOAP_TYPE_ns2__getConfigProfiles;
			return soap_in_ns2__getConfigProfiles(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getConfigProfilesResponse"))
		{	*type = SOAP_TYPE_ns2__getConfigProfilesResponse;
			return soap_in_ns2__getConfigProfilesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getBalance"))
		{	*type = SOAP_TYPE_ns2__getBalance;
			return soap_in_ns2__getBalance(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getBalanceResponse"))
		{	*type = SOAP_TYPE_ns2__getBalanceResponse;
			return soap_in_ns2__getBalanceResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getDispatchStatus"))
		{	*type = SOAP_TYPE_ns2__getDispatchStatus;
			return soap_in_ns2__getDispatchStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getDispatchStatusResponse"))
		{	*type = SOAP_TYPE_ns2__getDispatchStatusResponse;
			return soap_in_ns2__getDispatchStatusResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:dispatch"))
		{	*type = SOAP_TYPE_ns2__dispatch;
			return soap_in_ns2__dispatch(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:dispatchResponse"))
		{	*type = SOAP_TYPE_ns2__dispatchResponse;
			return soap_in_ns2__dispatchResponse(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "xsd:string"))
		{	*type = SOAP_TYPE_ArrayOfDispatchIds;
			return soap_in_ArrayOfDispatchIds(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:Option"))
		{	*type = SOAP_TYPE_ArrayOfOptions;
			return soap_in_ArrayOfOptions(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:Recipient"))
		{	*type = SOAP_TYPE_ArrayOfRecipients;
			return soap_in_ArrayOfRecipients(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:DocumentFile"))
		{	*type = SOAP_TYPE_ArrayOfDocumentFiles;
			return soap_in_ArrayOfDocumentFiles(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RemoveSenderReturnObject"))
		{	*type = SOAP_TYPE_ns1__RemoveSenderReturnObject;
			return soap_in_ns1__RemoveSenderReturnObject(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:VerifySenderReturnObject"))
		{	*type = SOAP_TYPE_ns1__VerifySenderReturnObject;
			return soap_in_ns1__VerifySenderReturnObject(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AddSenderReturnObject"))
		{	*type = SOAP_TYPE_ns1__AddSenderReturnObject;
			return soap_in_ns1__AddSenderReturnObject(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:ShipmentPrice"))
		{	*type = SOAP_TYPE_ArrayOfShipmentsPrice;
			return soap_in_ArrayOfShipmentsPrice(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PriceReturnObject"))
		{	*type = SOAP_TYPE_ns1__PriceReturnObject;
			return soap_in_ns1__PriceReturnObject(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CertificateReturnObject"))
		{	*type = SOAP_TYPE_ns1__CertificateReturnObject;
			return soap_in_ns1__CertificateReturnObject(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:Sender"))
		{	*type = SOAP_TYPE_ArrayOfSenders;
			return soap_in_ArrayOfSenders(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SendersReturnObject"))
		{	*type = SOAP_TYPE_ns1__SendersReturnObject;
			return soap_in_ns1__SendersReturnObject(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:ConfigProfile"))
		{	*type = SOAP_TYPE_ArrayOfConfigProfiles;
			return soap_in_ArrayOfConfigProfiles(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ConfigProfilesReturnObject"))
		{	*type = SOAP_TYPE_ns1__ConfigProfilesReturnObject;
			return soap_in_ns1__ConfigProfilesReturnObject(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:BalanceReturnObject"))
		{	*type = SOAP_TYPE_ns1__BalanceReturnObject;
			return soap_in_ns1__BalanceReturnObject(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:Shipment"))
		{	*type = SOAP_TYPE_ArrayOfShipments;
			return soap_in_ArrayOfShipments(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DispatchReturnObject"))
		{	*type = SOAP_TYPE_ns1__DispatchReturnObject;
			return soap_in_ns1__DispatchReturnObject(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SenderData"))
		{	*type = SOAP_TYPE_ns1__SenderData;
			return soap_in_ns1__SenderData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ShipmentPrice"))
		{	*type = SOAP_TYPE_ns1__ShipmentPrice;
			return soap_in_ns1__ShipmentPrice(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Sender"))
		{	*type = SOAP_TYPE_ns1__Sender;
			return soap_in_ns1__Sender(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ConfigProfile"))
		{	*type = SOAP_TYPE_ns1__ConfigProfile;
			return soap_in_ns1__ConfigProfile(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Shipment"))
		{	*type = SOAP_TYPE_ns1__Shipment;
			return soap_in_ns1__Shipment(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Option"))
		{	*type = SOAP_TYPE_ns1__Option;
			return soap_in_ns1__Option(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Recipient"))
		{	*type = SOAP_TYPE_ns1__Recipient;
			return soap_in_ns1__Recipient(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DocumentFile"))
		{	*type = SOAP_TYPE_ns1__DocumentFile;
			return soap_in_ns1__DocumentFile(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_float:
		return soap_out_float(soap, tag, id, (const float *)ptr, "xsd:float");
	case SOAP_TYPE_xsd__boolean:
		return soap_out_xsd__boolean(soap, tag, id, (const enum xsd__boolean *)ptr, "xsd:boolean");
	case SOAP_TYPE_ns2__removeSender:
		return soap_out_ns2__removeSender(soap, tag, id, (const struct ns2__removeSender *)ptr, "ns2:removeSender");
	case SOAP_TYPE_ns2__removeSenderResponse:
		return soap_out_ns2__removeSenderResponse(soap, tag, id, (const struct ns2__removeSenderResponse *)ptr, "ns2:removeSenderResponse");
	case SOAP_TYPE_ns2__verifySender:
		return soap_out_ns2__verifySender(soap, tag, id, (const struct ns2__verifySender *)ptr, "ns2:verifySender");
	case SOAP_TYPE_ns2__verifySenderResponse:
		return soap_out_ns2__verifySenderResponse(soap, tag, id, (const struct ns2__verifySenderResponse *)ptr, "ns2:verifySenderResponse");
	case SOAP_TYPE_ns2__addSender:
		return soap_out_ns2__addSender(soap, tag, id, (const struct ns2__addSender *)ptr, "ns2:addSender");
	case SOAP_TYPE_ns2__addSenderResponse:
		return soap_out_ns2__addSenderResponse(soap, tag, id, (const struct ns2__addSenderResponse *)ptr, "ns2:addSenderResponse");
	case SOAP_TYPE_ns2__getPrice:
		return soap_out_ns2__getPrice(soap, tag, id, (const struct ns2__getPrice *)ptr, "ns2:getPrice");
	case SOAP_TYPE_ns2__getPriceResponse:
		return soap_out_ns2__getPriceResponse(soap, tag, id, (const struct ns2__getPriceResponse *)ptr, "ns2:getPriceResponse");
	case SOAP_TYPE_ns2__getCertificate:
		return soap_out_ns2__getCertificate(soap, tag, id, (const struct ns2__getCertificate *)ptr, "ns2:getCertificate");
	case SOAP_TYPE_ns2__getCertificateResponse:
		return soap_out_ns2__getCertificateResponse(soap, tag, id, (const struct ns2__getCertificateResponse *)ptr, "ns2:getCertificateResponse");
	case SOAP_TYPE_ns2__getSenders:
		return soap_out_ns2__getSenders(soap, tag, id, (const struct ns2__getSenders *)ptr, "ns2:getSenders");
	case SOAP_TYPE_ns2__getSendersResponse:
		return soap_out_ns2__getSendersResponse(soap, tag, id, (const struct ns2__getSendersResponse *)ptr, "ns2:getSendersResponse");
	case SOAP_TYPE_ns2__getConfigProfiles:
		return soap_out_ns2__getConfigProfiles(soap, tag, id, (const struct ns2__getConfigProfiles *)ptr, "ns2:getConfigProfiles");
	case SOAP_TYPE_ns2__getConfigProfilesResponse:
		return soap_out_ns2__getConfigProfilesResponse(soap, tag, id, (const struct ns2__getConfigProfilesResponse *)ptr, "ns2:getConfigProfilesResponse");
	case SOAP_TYPE_ns2__getBalance:
		return soap_out_ns2__getBalance(soap, tag, id, (const struct ns2__getBalance *)ptr, "ns2:getBalance");
	case SOAP_TYPE_ns2__getBalanceResponse:
		return soap_out_ns2__getBalanceResponse(soap, tag, id, (const struct ns2__getBalanceResponse *)ptr, "ns2:getBalanceResponse");
	case SOAP_TYPE_ns2__getDispatchStatus:
		return soap_out_ns2__getDispatchStatus(soap, tag, id, (const struct ns2__getDispatchStatus *)ptr, "ns2:getDispatchStatus");
	case SOAP_TYPE_ns2__getDispatchStatusResponse:
		return soap_out_ns2__getDispatchStatusResponse(soap, tag, id, (const struct ns2__getDispatchStatusResponse *)ptr, "ns2:getDispatchStatusResponse");
	case SOAP_TYPE_ns2__dispatch:
		return soap_out_ns2__dispatch(soap, tag, id, (const struct ns2__dispatch *)ptr, "ns2:dispatch");
	case SOAP_TYPE_ns2__dispatchResponse:
		return soap_out_ns2__dispatchResponse(soap, tag, id, (const struct ns2__dispatchResponse *)ptr, "ns2:dispatchResponse");
	case SOAP_TYPE_ArrayOfDispatchIds:
		return soap_out_ArrayOfDispatchIds(soap, tag, id, (const struct ArrayOfDispatchIds *)ptr, "xsd:string");
	case SOAP_TYPE_ArrayOfOptions:
		return soap_out_ArrayOfOptions(soap, tag, id, (const struct ArrayOfOptions *)ptr, "ns1:Option");
	case SOAP_TYPE_ArrayOfRecipients:
		return soap_out_ArrayOfRecipients(soap, tag, id, (const struct ArrayOfRecipients *)ptr, "ns1:Recipient");
	case SOAP_TYPE_ArrayOfDocumentFiles:
		return soap_out_ArrayOfDocumentFiles(soap, tag, id, (const struct ArrayOfDocumentFiles *)ptr, "ns1:DocumentFile");
	case SOAP_TYPE_ns1__RemoveSenderReturnObject:
		return soap_out_ns1__RemoveSenderReturnObject(soap, tag, id, (const struct ns1__RemoveSenderReturnObject *)ptr, "ns1:RemoveSenderReturnObject");
	case SOAP_TYPE_ns1__VerifySenderReturnObject:
		return soap_out_ns1__VerifySenderReturnObject(soap, tag, id, (const struct ns1__VerifySenderReturnObject *)ptr, "ns1:VerifySenderReturnObject");
	case SOAP_TYPE_ns1__AddSenderReturnObject:
		return soap_out_ns1__AddSenderReturnObject(soap, tag, id, (const struct ns1__AddSenderReturnObject *)ptr, "ns1:AddSenderReturnObject");
	case SOAP_TYPE_ArrayOfShipmentsPrice:
		return soap_out_ArrayOfShipmentsPrice(soap, tag, id, (const struct ArrayOfShipmentsPrice *)ptr, "ns1:ShipmentPrice");
	case SOAP_TYPE_ns1__PriceReturnObject:
		return soap_out_ns1__PriceReturnObject(soap, tag, id, (const struct ns1__PriceReturnObject *)ptr, "ns1:PriceReturnObject");
	case SOAP_TYPE_ns1__CertificateReturnObject:
		return soap_out_ns1__CertificateReturnObject(soap, tag, id, (const struct ns1__CertificateReturnObject *)ptr, "ns1:CertificateReturnObject");
	case SOAP_TYPE_ArrayOfSenders:
		return soap_out_ArrayOfSenders(soap, tag, id, (const struct ArrayOfSenders *)ptr, "ns1:Sender");
	case SOAP_TYPE_ns1__SendersReturnObject:
		return soap_out_ns1__SendersReturnObject(soap, tag, id, (const struct ns1__SendersReturnObject *)ptr, "ns1:SendersReturnObject");
	case SOAP_TYPE_ArrayOfConfigProfiles:
		return soap_out_ArrayOfConfigProfiles(soap, tag, id, (const struct ArrayOfConfigProfiles *)ptr, "ns1:ConfigProfile");
	case SOAP_TYPE_ns1__ConfigProfilesReturnObject:
		return soap_out_ns1__ConfigProfilesReturnObject(soap, tag, id, (const struct ns1__ConfigProfilesReturnObject *)ptr, "ns1:ConfigProfilesReturnObject");
	case SOAP_TYPE_ns1__BalanceReturnObject:
		return soap_out_ns1__BalanceReturnObject(soap, tag, id, (const struct ns1__BalanceReturnObject *)ptr, "ns1:BalanceReturnObject");
	case SOAP_TYPE_ArrayOfShipments:
		return soap_out_ArrayOfShipments(soap, tag, id, (const struct ArrayOfShipments *)ptr, "ns1:Shipment");
	case SOAP_TYPE_ns1__DispatchReturnObject:
		return soap_out_ns1__DispatchReturnObject(soap, tag, id, (const struct ns1__DispatchReturnObject *)ptr, "ns1:DispatchReturnObject");
	case SOAP_TYPE_ns1__SenderData:
		return soap_out_ns1__SenderData(soap, tag, id, (const struct ns1__SenderData *)ptr, "ns1:SenderData");
	case SOAP_TYPE_ns1__ShipmentPrice:
		return soap_out_ns1__ShipmentPrice(soap, tag, id, (const struct ns1__ShipmentPrice *)ptr, "ns1:ShipmentPrice");
	case SOAP_TYPE_ns1__Sender:
		return soap_out_ns1__Sender(soap, tag, id, (const struct ns1__Sender *)ptr, "ns1:Sender");
	case SOAP_TYPE_ns1__ConfigProfile:
		return soap_out_ns1__ConfigProfile(soap, tag, id, (const struct ns1__ConfigProfile *)ptr, "ns1:ConfigProfile");
	case SOAP_TYPE_ns1__Shipment:
		return soap_out_ns1__Shipment(soap, tag, id, (const struct ns1__Shipment *)ptr, "ns1:Shipment");
	case SOAP_TYPE_ns1__Option:
		return soap_out_ns1__Option(soap, tag, id, (const struct ns1__Option *)ptr, "ns1:Option");
	case SOAP_TYPE_ns1__Recipient:
		return soap_out_ns1__Recipient(soap, tag, id, (const struct ns1__Recipient *)ptr, "ns1:Recipient");
	case SOAP_TYPE_ns1__DocumentFile:
		return soap_out_ns1__DocumentFile(soap, tag, id, (const struct ns1__DocumentFile *)ptr, "ns1:DocumentFile");
	case SOAP_TYPE_PointerTons2__removeSenderResponse:
		return soap_out_PointerTons2__removeSenderResponse(soap, tag, id, (struct ns2__removeSenderResponse *const*)ptr, "ns2:removeSenderResponse");
	case SOAP_TYPE_PointerTons1__RemoveSenderReturnObject:
		return soap_out_PointerTons1__RemoveSenderReturnObject(soap, tag, id, (struct ns1__RemoveSenderReturnObject *const*)ptr, "ns1:RemoveSenderReturnObject");
	case SOAP_TYPE_PointerTons2__verifySenderResponse:
		return soap_out_PointerTons2__verifySenderResponse(soap, tag, id, (struct ns2__verifySenderResponse *const*)ptr, "ns2:verifySenderResponse");
	case SOAP_TYPE_PointerTons1__VerifySenderReturnObject:
		return soap_out_PointerTons1__VerifySenderReturnObject(soap, tag, id, (struct ns1__VerifySenderReturnObject *const*)ptr, "ns1:VerifySenderReturnObject");
	case SOAP_TYPE_PointerTons2__addSenderResponse:
		return soap_out_PointerTons2__addSenderResponse(soap, tag, id, (struct ns2__addSenderResponse *const*)ptr, "ns2:addSenderResponse");
	case SOAP_TYPE_PointerTons1__SenderData:
		return soap_out_PointerTons1__SenderData(soap, tag, id, (struct ns1__SenderData *const*)ptr, "ns1:SenderData");
	case SOAP_TYPE_PointerTons1__AddSenderReturnObject:
		return soap_out_PointerTons1__AddSenderReturnObject(soap, tag, id, (struct ns1__AddSenderReturnObject *const*)ptr, "ns1:AddSenderReturnObject");
	case SOAP_TYPE_PointerTons2__getPriceResponse:
		return soap_out_PointerTons2__getPriceResponse(soap, tag, id, (struct ns2__getPriceResponse *const*)ptr, "ns2:getPriceResponse");
	case SOAP_TYPE_PointerTons1__PriceReturnObject:
		return soap_out_PointerTons1__PriceReturnObject(soap, tag, id, (struct ns1__PriceReturnObject *const*)ptr, "ns1:PriceReturnObject");
	case SOAP_TYPE_PointerTons2__getCertificateResponse:
		return soap_out_PointerTons2__getCertificateResponse(soap, tag, id, (struct ns2__getCertificateResponse *const*)ptr, "ns2:getCertificateResponse");
	case SOAP_TYPE_PointerTons1__CertificateReturnObject:
		return soap_out_PointerTons1__CertificateReturnObject(soap, tag, id, (struct ns1__CertificateReturnObject *const*)ptr, "ns1:CertificateReturnObject");
	case SOAP_TYPE_PointerTons2__getSendersResponse:
		return soap_out_PointerTons2__getSendersResponse(soap, tag, id, (struct ns2__getSendersResponse *const*)ptr, "ns2:getSendersResponse");
	case SOAP_TYPE_PointerTons1__SendersReturnObject:
		return soap_out_PointerTons1__SendersReturnObject(soap, tag, id, (struct ns1__SendersReturnObject *const*)ptr, "ns1:SendersReturnObject");
	case SOAP_TYPE_PointerTons2__getConfigProfilesResponse:
		return soap_out_PointerTons2__getConfigProfilesResponse(soap, tag, id, (struct ns2__getConfigProfilesResponse *const*)ptr, "ns2:getConfigProfilesResponse");
	case SOAP_TYPE_PointerTons1__ConfigProfilesReturnObject:
		return soap_out_PointerTons1__ConfigProfilesReturnObject(soap, tag, id, (struct ns1__ConfigProfilesReturnObject *const*)ptr, "ns1:ConfigProfilesReturnObject");
	case SOAP_TYPE_PointerTons2__getBalanceResponse:
		return soap_out_PointerTons2__getBalanceResponse(soap, tag, id, (struct ns2__getBalanceResponse *const*)ptr, "ns2:getBalanceResponse");
	case SOAP_TYPE_PointerTons1__BalanceReturnObject:
		return soap_out_PointerTons1__BalanceReturnObject(soap, tag, id, (struct ns1__BalanceReturnObject *const*)ptr, "ns1:BalanceReturnObject");
	case SOAP_TYPE_PointerTons2__getDispatchStatusResponse:
		return soap_out_PointerTons2__getDispatchStatusResponse(soap, tag, id, (struct ns2__getDispatchStatusResponse *const*)ptr, "ns2:getDispatchStatusResponse");
	case SOAP_TYPE_PointerToArrayOfDispatchIds:
		return soap_out_PointerToArrayOfDispatchIds(soap, tag, id, (struct ArrayOfDispatchIds *const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerTons2__dispatchResponse:
		return soap_out_PointerTons2__dispatchResponse(soap, tag, id, (struct ns2__dispatchResponse *const*)ptr, "ns2:dispatchResponse");
	case SOAP_TYPE_PointerToArrayOfOptions:
		return soap_out_PointerToArrayOfOptions(soap, tag, id, (struct ArrayOfOptions *const*)ptr, "ns1:Option");
	case SOAP_TYPE_PointerToArrayOfRecipients:
		return soap_out_PointerToArrayOfRecipients(soap, tag, id, (struct ArrayOfRecipients *const*)ptr, "ns1:Recipient");
	case SOAP_TYPE_PointerToArrayOfDocumentFiles:
		return soap_out_PointerToArrayOfDocumentFiles(soap, tag, id, (struct ArrayOfDocumentFiles *const*)ptr, "ns1:DocumentFile");
	case SOAP_TYPE_PointerTons1__DispatchReturnObject:
		return soap_out_PointerTons1__DispatchReturnObject(soap, tag, id, (struct ns1__DispatchReturnObject *const*)ptr, "ns1:DispatchReturnObject");
	case SOAP_TYPE_PointerToPointerTons1__ShipmentPrice:
		return soap_out_PointerToPointerTons1__ShipmentPrice(soap, tag, id, (struct ns1__ShipmentPrice **const*)ptr, "ns1:ShipmentPrice");
	case SOAP_TYPE_PointerTons1__ShipmentPrice:
		return soap_out_PointerTons1__ShipmentPrice(soap, tag, id, (struct ns1__ShipmentPrice *const*)ptr, "ns1:ShipmentPrice");
	case SOAP_TYPE_PointerToPointerTons1__Sender:
		return soap_out_PointerToPointerTons1__Sender(soap, tag, id, (struct ns1__Sender **const*)ptr, "ns1:Sender");
	case SOAP_TYPE_PointerTons1__Sender:
		return soap_out_PointerTons1__Sender(soap, tag, id, (struct ns1__Sender *const*)ptr, "ns1:Sender");
	case SOAP_TYPE_PointerToPointerTons1__ConfigProfile:
		return soap_out_PointerToPointerTons1__ConfigProfile(soap, tag, id, (struct ns1__ConfigProfile **const*)ptr, "ns1:ConfigProfile");
	case SOAP_TYPE_PointerTons1__ConfigProfile:
		return soap_out_PointerTons1__ConfigProfile(soap, tag, id, (struct ns1__ConfigProfile *const*)ptr, "ns1:ConfigProfile");
	case SOAP_TYPE_PointerTostring:
		return soap_out_PointerTostring(soap, tag, id, (char **const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerToPointerTons1__Shipment:
		return soap_out_PointerToPointerTons1__Shipment(soap, tag, id, (struct ns1__Shipment **const*)ptr, "ns1:Shipment");
	case SOAP_TYPE_PointerTons1__Shipment:
		return soap_out_PointerTons1__Shipment(soap, tag, id, (struct ns1__Shipment *const*)ptr, "ns1:Shipment");
	case SOAP_TYPE_PointerToPointerTons1__Option:
		return soap_out_PointerToPointerTons1__Option(soap, tag, id, (struct ns1__Option **const*)ptr, "ns1:Option");
	case SOAP_TYPE_PointerTons1__Option:
		return soap_out_PointerTons1__Option(soap, tag, id, (struct ns1__Option *const*)ptr, "ns1:Option");
	case SOAP_TYPE_PointerToPointerTons1__Recipient:
		return soap_out_PointerToPointerTons1__Recipient(soap, tag, id, (struct ns1__Recipient **const*)ptr, "ns1:Recipient");
	case SOAP_TYPE_PointerTons1__Recipient:
		return soap_out_PointerTons1__Recipient(soap, tag, id, (struct ns1__Recipient *const*)ptr, "ns1:Recipient");
	case SOAP_TYPE_PointerToPointerTons1__DocumentFile:
		return soap_out_PointerToPointerTons1__DocumentFile(soap, tag, id, (struct ns1__DocumentFile **const*)ptr, "ns1:DocumentFile");
	case SOAP_TYPE_PointerTons1__DocumentFile:
		return soap_out_PointerTons1__DocumentFile(soap, tag, id, (struct ns1__DocumentFile *const*)ptr, "ns1:DocumentFile");
	case SOAP_TYPE_PointerToArrayOfShipmentsPrice:
		return soap_out_PointerToArrayOfShipmentsPrice(soap, tag, id, (struct ArrayOfShipmentsPrice *const*)ptr, "ns1:ShipmentPrice");
	case SOAP_TYPE_PointerToArrayOfSenders:
		return soap_out_PointerToArrayOfSenders(soap, tag, id, (struct ArrayOfSenders *const*)ptr, "ns1:Sender");
	case SOAP_TYPE_PointerToArrayOfConfigProfiles:
		return soap_out_PointerToArrayOfConfigProfiles(soap, tag, id, (struct ArrayOfConfigProfiles *const*)ptr, "ns1:ConfigProfile");
	case SOAP_TYPE_PointerToArrayOfShipments:
		return soap_out_PointerToArrayOfShipments(soap, tag, id, (struct ArrayOfShipments *const*)ptr, "ns1:Shipment");
	case SOAP_TYPE_PointerTofloat:
		return soap_out_PointerTofloat(soap, tag, id, (float *const*)ptr, "xsd:float");
	case SOAP_TYPE_PointerToint:
		return soap_out_PointerToint(soap, tag, id, (int *const*)ptr, "xsd:int");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_ns2__removeSender:
		soap_serialize_ns2__removeSender(soap, (const struct ns2__removeSender *)ptr);
		break;
	case SOAP_TYPE_ns2__removeSenderResponse:
		soap_serialize_ns2__removeSenderResponse(soap, (const struct ns2__removeSenderResponse *)ptr);
		break;
	case SOAP_TYPE_ns2__verifySender:
		soap_serialize_ns2__verifySender(soap, (const struct ns2__verifySender *)ptr);
		break;
	case SOAP_TYPE_ns2__verifySenderResponse:
		soap_serialize_ns2__verifySenderResponse(soap, (const struct ns2__verifySenderResponse *)ptr);
		break;
	case SOAP_TYPE_ns2__addSender:
		soap_serialize_ns2__addSender(soap, (const struct ns2__addSender *)ptr);
		break;
	case SOAP_TYPE_ns2__addSenderResponse:
		soap_serialize_ns2__addSenderResponse(soap, (const struct ns2__addSenderResponse *)ptr);
		break;
	case SOAP_TYPE_ns2__getPrice:
		soap_serialize_ns2__getPrice(soap, (const struct ns2__getPrice *)ptr);
		break;
	case SOAP_TYPE_ns2__getPriceResponse:
		soap_serialize_ns2__getPriceResponse(soap, (const struct ns2__getPriceResponse *)ptr);
		break;
	case SOAP_TYPE_ns2__getCertificate:
		soap_serialize_ns2__getCertificate(soap, (const struct ns2__getCertificate *)ptr);
		break;
	case SOAP_TYPE_ns2__getCertificateResponse:
		soap_serialize_ns2__getCertificateResponse(soap, (const struct ns2__getCertificateResponse *)ptr);
		break;
	case SOAP_TYPE_ns2__getSenders:
		soap_serialize_ns2__getSenders(soap, (const struct ns2__getSenders *)ptr);
		break;
	case SOAP_TYPE_ns2__getSendersResponse:
		soap_serialize_ns2__getSendersResponse(soap, (const struct ns2__getSendersResponse *)ptr);
		break;
	case SOAP_TYPE_ns2__getConfigProfiles:
		soap_serialize_ns2__getConfigProfiles(soap, (const struct ns2__getConfigProfiles *)ptr);
		break;
	case SOAP_TYPE_ns2__getConfigProfilesResponse:
		soap_serialize_ns2__getConfigProfilesResponse(soap, (const struct ns2__getConfigProfilesResponse *)ptr);
		break;
	case SOAP_TYPE_ns2__getBalance:
		soap_serialize_ns2__getBalance(soap, (const struct ns2__getBalance *)ptr);
		break;
	case SOAP_TYPE_ns2__getBalanceResponse:
		soap_serialize_ns2__getBalanceResponse(soap, (const struct ns2__getBalanceResponse *)ptr);
		break;
	case SOAP_TYPE_ns2__getDispatchStatus:
		soap_serialize_ns2__getDispatchStatus(soap, (const struct ns2__getDispatchStatus *)ptr);
		break;
	case SOAP_TYPE_ns2__getDispatchStatusResponse:
		soap_serialize_ns2__getDispatchStatusResponse(soap, (const struct ns2__getDispatchStatusResponse *)ptr);
		break;
	case SOAP_TYPE_ns2__dispatch:
		soap_serialize_ns2__dispatch(soap, (const struct ns2__dispatch *)ptr);
		break;
	case SOAP_TYPE_ns2__dispatchResponse:
		soap_serialize_ns2__dispatchResponse(soap, (const struct ns2__dispatchResponse *)ptr);
		break;
	case SOAP_TYPE_ArrayOfDispatchIds:
		soap_serialize_ArrayOfDispatchIds(soap, (const struct ArrayOfDispatchIds *)ptr);
		break;
	case SOAP_TYPE_ArrayOfOptions:
		soap_serialize_ArrayOfOptions(soap, (const struct ArrayOfOptions *)ptr);
		break;
	case SOAP_TYPE_ArrayOfRecipients:
		soap_serialize_ArrayOfRecipients(soap, (const struct ArrayOfRecipients *)ptr);
		break;
	case SOAP_TYPE_ArrayOfDocumentFiles:
		soap_serialize_ArrayOfDocumentFiles(soap, (const struct ArrayOfDocumentFiles *)ptr);
		break;
	case SOAP_TYPE_ns1__RemoveSenderReturnObject:
		soap_serialize_ns1__RemoveSenderReturnObject(soap, (const struct ns1__RemoveSenderReturnObject *)ptr);
		break;
	case SOAP_TYPE_ns1__VerifySenderReturnObject:
		soap_serialize_ns1__VerifySenderReturnObject(soap, (const struct ns1__VerifySenderReturnObject *)ptr);
		break;
	case SOAP_TYPE_ns1__AddSenderReturnObject:
		soap_serialize_ns1__AddSenderReturnObject(soap, (const struct ns1__AddSenderReturnObject *)ptr);
		break;
	case SOAP_TYPE_ArrayOfShipmentsPrice:
		soap_serialize_ArrayOfShipmentsPrice(soap, (const struct ArrayOfShipmentsPrice *)ptr);
		break;
	case SOAP_TYPE_ns1__PriceReturnObject:
		soap_serialize_ns1__PriceReturnObject(soap, (const struct ns1__PriceReturnObject *)ptr);
		break;
	case SOAP_TYPE_ns1__CertificateReturnObject:
		soap_serialize_ns1__CertificateReturnObject(soap, (const struct ns1__CertificateReturnObject *)ptr);
		break;
	case SOAP_TYPE_ArrayOfSenders:
		soap_serialize_ArrayOfSenders(soap, (const struct ArrayOfSenders *)ptr);
		break;
	case SOAP_TYPE_ns1__SendersReturnObject:
		soap_serialize_ns1__SendersReturnObject(soap, (const struct ns1__SendersReturnObject *)ptr);
		break;
	case SOAP_TYPE_ArrayOfConfigProfiles:
		soap_serialize_ArrayOfConfigProfiles(soap, (const struct ArrayOfConfigProfiles *)ptr);
		break;
	case SOAP_TYPE_ns1__ConfigProfilesReturnObject:
		soap_serialize_ns1__ConfigProfilesReturnObject(soap, (const struct ns1__ConfigProfilesReturnObject *)ptr);
		break;
	case SOAP_TYPE_ns1__BalanceReturnObject:
		soap_serialize_ns1__BalanceReturnObject(soap, (const struct ns1__BalanceReturnObject *)ptr);
		break;
	case SOAP_TYPE_ArrayOfShipments:
		soap_serialize_ArrayOfShipments(soap, (const struct ArrayOfShipments *)ptr);
		break;
	case SOAP_TYPE_ns1__DispatchReturnObject:
		soap_serialize_ns1__DispatchReturnObject(soap, (const struct ns1__DispatchReturnObject *)ptr);
		break;
	case SOAP_TYPE_ns1__SenderData:
		soap_serialize_ns1__SenderData(soap, (const struct ns1__SenderData *)ptr);
		break;
	case SOAP_TYPE_ns1__ShipmentPrice:
		soap_serialize_ns1__ShipmentPrice(soap, (const struct ns1__ShipmentPrice *)ptr);
		break;
	case SOAP_TYPE_ns1__Sender:
		soap_serialize_ns1__Sender(soap, (const struct ns1__Sender *)ptr);
		break;
	case SOAP_TYPE_ns1__ConfigProfile:
		soap_serialize_ns1__ConfigProfile(soap, (const struct ns1__ConfigProfile *)ptr);
		break;
	case SOAP_TYPE_ns1__Shipment:
		soap_serialize_ns1__Shipment(soap, (const struct ns1__Shipment *)ptr);
		break;
	case SOAP_TYPE_ns1__Option:
		soap_serialize_ns1__Option(soap, (const struct ns1__Option *)ptr);
		break;
	case SOAP_TYPE_ns1__Recipient:
		soap_serialize_ns1__Recipient(soap, (const struct ns1__Recipient *)ptr);
		break;
	case SOAP_TYPE_ns1__DocumentFile:
		soap_serialize_ns1__DocumentFile(soap, (const struct ns1__DocumentFile *)ptr);
		break;
	case SOAP_TYPE_PointerTons2__removeSenderResponse:
		soap_serialize_PointerTons2__removeSenderResponse(soap, (struct ns2__removeSenderResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__RemoveSenderReturnObject:
		soap_serialize_PointerTons1__RemoveSenderReturnObject(soap, (struct ns1__RemoveSenderReturnObject *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__verifySenderResponse:
		soap_serialize_PointerTons2__verifySenderResponse(soap, (struct ns2__verifySenderResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__VerifySenderReturnObject:
		soap_serialize_PointerTons1__VerifySenderReturnObject(soap, (struct ns1__VerifySenderReturnObject *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__addSenderResponse:
		soap_serialize_PointerTons2__addSenderResponse(soap, (struct ns2__addSenderResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SenderData:
		soap_serialize_PointerTons1__SenderData(soap, (struct ns1__SenderData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__AddSenderReturnObject:
		soap_serialize_PointerTons1__AddSenderReturnObject(soap, (struct ns1__AddSenderReturnObject *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__getPriceResponse:
		soap_serialize_PointerTons2__getPriceResponse(soap, (struct ns2__getPriceResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__PriceReturnObject:
		soap_serialize_PointerTons1__PriceReturnObject(soap, (struct ns1__PriceReturnObject *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__getCertificateResponse:
		soap_serialize_PointerTons2__getCertificateResponse(soap, (struct ns2__getCertificateResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CertificateReturnObject:
		soap_serialize_PointerTons1__CertificateReturnObject(soap, (struct ns1__CertificateReturnObject *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__getSendersResponse:
		soap_serialize_PointerTons2__getSendersResponse(soap, (struct ns2__getSendersResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SendersReturnObject:
		soap_serialize_PointerTons1__SendersReturnObject(soap, (struct ns1__SendersReturnObject *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__getConfigProfilesResponse:
		soap_serialize_PointerTons2__getConfigProfilesResponse(soap, (struct ns2__getConfigProfilesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ConfigProfilesReturnObject:
		soap_serialize_PointerTons1__ConfigProfilesReturnObject(soap, (struct ns1__ConfigProfilesReturnObject *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__getBalanceResponse:
		soap_serialize_PointerTons2__getBalanceResponse(soap, (struct ns2__getBalanceResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__BalanceReturnObject:
		soap_serialize_PointerTons1__BalanceReturnObject(soap, (struct ns1__BalanceReturnObject *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__getDispatchStatusResponse:
		soap_serialize_PointerTons2__getDispatchStatusResponse(soap, (struct ns2__getDispatchStatusResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfDispatchIds:
		soap_serialize_PointerToArrayOfDispatchIds(soap, (struct ArrayOfDispatchIds *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__dispatchResponse:
		soap_serialize_PointerTons2__dispatchResponse(soap, (struct ns2__dispatchResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfOptions:
		soap_serialize_PointerToArrayOfOptions(soap, (struct ArrayOfOptions *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfRecipients:
		soap_serialize_PointerToArrayOfRecipients(soap, (struct ArrayOfRecipients *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfDocumentFiles:
		soap_serialize_PointerToArrayOfDocumentFiles(soap, (struct ArrayOfDocumentFiles *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__DispatchReturnObject:
		soap_serialize_PointerTons1__DispatchReturnObject(soap, (struct ns1__DispatchReturnObject *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__ShipmentPrice:
		soap_serialize_PointerToPointerTons1__ShipmentPrice(soap, (struct ns1__ShipmentPrice **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ShipmentPrice:
		soap_serialize_PointerTons1__ShipmentPrice(soap, (struct ns1__ShipmentPrice *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__Sender:
		soap_serialize_PointerToPointerTons1__Sender(soap, (struct ns1__Sender **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Sender:
		soap_serialize_PointerTons1__Sender(soap, (struct ns1__Sender *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__ConfigProfile:
		soap_serialize_PointerToPointerTons1__ConfigProfile(soap, (struct ns1__ConfigProfile **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ConfigProfile:
		soap_serialize_PointerTons1__ConfigProfile(soap, (struct ns1__ConfigProfile *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostring:
		soap_serialize_PointerTostring(soap, (char **const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__Shipment:
		soap_serialize_PointerToPointerTons1__Shipment(soap, (struct ns1__Shipment **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Shipment:
		soap_serialize_PointerTons1__Shipment(soap, (struct ns1__Shipment *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__Option:
		soap_serialize_PointerToPointerTons1__Option(soap, (struct ns1__Option **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Option:
		soap_serialize_PointerTons1__Option(soap, (struct ns1__Option *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__Recipient:
		soap_serialize_PointerToPointerTons1__Recipient(soap, (struct ns1__Recipient **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Recipient:
		soap_serialize_PointerTons1__Recipient(soap, (struct ns1__Recipient *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__DocumentFile:
		soap_serialize_PointerToPointerTons1__DocumentFile(soap, (struct ns1__DocumentFile **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__DocumentFile:
		soap_serialize_PointerTons1__DocumentFile(soap, (struct ns1__DocumentFile *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfShipmentsPrice:
		soap_serialize_PointerToArrayOfShipmentsPrice(soap, (struct ArrayOfShipmentsPrice *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfSenders:
		soap_serialize_PointerToArrayOfSenders(soap, (struct ArrayOfSenders *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfConfigProfiles:
		soap_serialize_PointerToArrayOfConfigProfiles(soap, (struct ArrayOfConfigProfiles *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfShipments:
		soap_serialize_PointerToArrayOfShipments(soap, (struct ArrayOfShipments *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofloat:
		soap_serialize_PointerTofloat(soap, (float *const*)ptr);
		break;
	case SOAP_TYPE_PointerToint:
		soap_serialize_PointerToint(soap, (int *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_float(struct soap *soap, float *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_float
	*a = SOAP_DEFAULT_float;
#else
	*a = (float)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_float(struct soap *soap, const float *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_float);
	if (soap_out_float(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_float(struct soap *soap, const char *tag, int id, const float *a, const char *type)
{
	return soap_outfloat(soap, tag, id, a, type, SOAP_TYPE_float);
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_get_float(struct soap *soap, float *p, const char *tag, const char *type)
{
	if ((p = soap_in_float(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_in_float(struct soap *soap, const char *tag, float *a, const char *type)
{	float *p;
	p = soap_infloat(soap, tag, a, type, SOAP_TYPE_float);
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__boolean(struct soap *soap, enum xsd__boolean *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_xsd__boolean
	*a = SOAP_DEFAULT_xsd__boolean;
#else
	*a = (enum xsd__boolean)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__boolean(struct soap *soap, const enum xsd__boolean *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__boolean);
	if (soap_out_xsd__boolean(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_xsd__boolean[] =
{	{ (long)xsd__boolean__false_, "false" },
	{ (long)xsd__boolean__true_, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_xsd__boolean2s(struct soap *soap, enum xsd__boolean n)
{	return soap_code_str(soap_codes_xsd__boolean, n!=0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__boolean(struct soap *soap, const char *tag, int id, const enum xsd__boolean *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xsd__boolean), type) || soap_send(soap, soap_xsd__boolean2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum xsd__boolean * SOAP_FMAC4 soap_get_xsd__boolean(struct soap *soap, enum xsd__boolean *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__boolean(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2xsd__boolean(struct soap *soap, const char *s, enum xsd__boolean *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_xsd__boolean, s);
	if (map)
		*a = (enum xsd__boolean)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum xsd__boolean)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum xsd__boolean * SOAP_FMAC4 soap_in_xsd__boolean(struct soap *soap, const char *tag, enum xsd__boolean *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum xsd__boolean *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__boolean, sizeof(enum xsd__boolean), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2xsd__boolean(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum xsd__boolean *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xsd__boolean, 0, sizeof(enum xsd__boolean), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__type = 0;
	a->fault = NULL;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag_fault = 1;
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__removeSender(struct soap *soap, struct ns2__removeSender *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->login);
	soap_default_string(soap, &a->api_USCOREpass);
	soap_default_int(soap, &a->sender_USCOREid);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__removeSender(struct soap *soap, const struct ns2__removeSender *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->login);
	soap_serialize_string(soap, &a->api_USCOREpass);
	soap_embedded(soap, &a->sender_USCOREid, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__removeSender(struct soap *soap, const struct ns2__removeSender *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__removeSender);
	if (soap_out_ns2__removeSender(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__removeSender(struct soap *soap, const char *tag, int id, const struct ns2__removeSender *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__removeSender), type))
		return soap->error;
	if (soap_out_string(soap, "login", -1, &a->login, ""))
		return soap->error;
	if (soap_out_string(soap, "api_pass", -1, &a->api_USCOREpass, ""))
		return soap->error;
	if (soap_out_int(soap, "sender_id", -1, &a->sender_USCOREid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__removeSender * SOAP_FMAC4 soap_get_ns2__removeSender(struct soap *soap, struct ns2__removeSender *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__removeSender(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns2__removeSender * SOAP_FMAC4 soap_in_ns2__removeSender(struct soap *soap, const char *tag, struct ns2__removeSender *a, const char *type)
{
	size_t soap_flag_login = 1;
	size_t soap_flag_api_USCOREpass = 1;
	size_t soap_flag_sender_USCOREid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__removeSender *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__removeSender, sizeof(struct ns2__removeSender), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__removeSender(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_login && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "login", &a->login, "xsd:string"))
				{	soap_flag_login--;
					continue;
				}
			if (soap_flag_api_USCOREpass && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "api_pass", &a->api_USCOREpass, "xsd:string"))
				{	soap_flag_api_USCOREpass--;
					continue;
				}
			if (soap_flag_sender_USCOREid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "sender_id", &a->sender_USCOREid, "xsd:int"))
				{	soap_flag_sender_USCOREid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__removeSender *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__removeSender, 0, sizeof(struct ns2__removeSender), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_sender_USCOREid > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__removeSenderResponse(struct soap *soap, struct ns2__removeSenderResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__removeSenderResponse(struct soap *soap, const struct ns2__removeSenderResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__RemoveSenderReturnObject(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__removeSenderResponse(struct soap *soap, const struct ns2__removeSenderResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__removeSenderResponse);
	if (soap_out_ns2__removeSenderResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__removeSenderResponse(struct soap *soap, const char *tag, int id, const struct ns2__removeSenderResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__removeSenderResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__RemoveSenderReturnObject(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__removeSenderResponse * SOAP_FMAC4 soap_get_ns2__removeSenderResponse(struct soap *soap, struct ns2__removeSenderResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__removeSenderResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns2__removeSenderResponse * SOAP_FMAC4 soap_in_ns2__removeSenderResponse(struct soap *soap, const char *tag, struct ns2__removeSenderResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__removeSenderResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__removeSenderResponse, sizeof(struct ns2__removeSenderResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__removeSenderResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__RemoveSenderReturnObject(soap, "return", &a->return_, "ns1:RemoveSenderReturnObject"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__removeSenderResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__removeSenderResponse, 0, sizeof(struct ns2__removeSenderResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__verifySender(struct soap *soap, struct ns2__verifySender *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->login);
	soap_default_string(soap, &a->api_USCOREpass);
	soap_default_int(soap, &a->sender_USCOREid);
	soap_default_string(soap, &a->verification_USCOREcode);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__verifySender(struct soap *soap, const struct ns2__verifySender *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->login);
	soap_serialize_string(soap, &a->api_USCOREpass);
	soap_embedded(soap, &a->sender_USCOREid, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->verification_USCOREcode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__verifySender(struct soap *soap, const struct ns2__verifySender *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__verifySender);
	if (soap_out_ns2__verifySender(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__verifySender(struct soap *soap, const char *tag, int id, const struct ns2__verifySender *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__verifySender), type))
		return soap->error;
	if (soap_out_string(soap, "login", -1, &a->login, ""))
		return soap->error;
	if (soap_out_string(soap, "api_pass", -1, &a->api_USCOREpass, ""))
		return soap->error;
	if (soap_out_int(soap, "sender_id", -1, &a->sender_USCOREid, ""))
		return soap->error;
	if (soap_out_string(soap, "verification_code", -1, &a->verification_USCOREcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__verifySender * SOAP_FMAC4 soap_get_ns2__verifySender(struct soap *soap, struct ns2__verifySender *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__verifySender(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns2__verifySender * SOAP_FMAC4 soap_in_ns2__verifySender(struct soap *soap, const char *tag, struct ns2__verifySender *a, const char *type)
{
	size_t soap_flag_login = 1;
	size_t soap_flag_api_USCOREpass = 1;
	size_t soap_flag_sender_USCOREid = 1;
	size_t soap_flag_verification_USCOREcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__verifySender *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__verifySender, sizeof(struct ns2__verifySender), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__verifySender(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_login && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "login", &a->login, "xsd:string"))
				{	soap_flag_login--;
					continue;
				}
			if (soap_flag_api_USCOREpass && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "api_pass", &a->api_USCOREpass, "xsd:string"))
				{	soap_flag_api_USCOREpass--;
					continue;
				}
			if (soap_flag_sender_USCOREid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "sender_id", &a->sender_USCOREid, "xsd:int"))
				{	soap_flag_sender_USCOREid--;
					continue;
				}
			if (soap_flag_verification_USCOREcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "verification_code", &a->verification_USCOREcode, "xsd:string"))
				{	soap_flag_verification_USCOREcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__verifySender *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__verifySender, 0, sizeof(struct ns2__verifySender), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_sender_USCOREid > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__verifySenderResponse(struct soap *soap, struct ns2__verifySenderResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__verifySenderResponse(struct soap *soap, const struct ns2__verifySenderResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__VerifySenderReturnObject(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__verifySenderResponse(struct soap *soap, const struct ns2__verifySenderResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__verifySenderResponse);
	if (soap_out_ns2__verifySenderResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__verifySenderResponse(struct soap *soap, const char *tag, int id, const struct ns2__verifySenderResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__verifySenderResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__VerifySenderReturnObject(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__verifySenderResponse * SOAP_FMAC4 soap_get_ns2__verifySenderResponse(struct soap *soap, struct ns2__verifySenderResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__verifySenderResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns2__verifySenderResponse * SOAP_FMAC4 soap_in_ns2__verifySenderResponse(struct soap *soap, const char *tag, struct ns2__verifySenderResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__verifySenderResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__verifySenderResponse, sizeof(struct ns2__verifySenderResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__verifySenderResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__VerifySenderReturnObject(soap, "return", &a->return_, "ns1:VerifySenderReturnObject"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__verifySenderResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__verifySenderResponse, 0, sizeof(struct ns2__verifySenderResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__addSender(struct soap *soap, struct ns2__addSender *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->login);
	soap_default_string(soap, &a->api_USCOREpass);
	a->sender_USCOREdata = NULL;
	soap_default_xsd__boolean(soap, &a->accept_USCOREterms);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__addSender(struct soap *soap, const struct ns2__addSender *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->login);
	soap_serialize_string(soap, &a->api_USCOREpass);
	soap_serialize_PointerTons1__SenderData(soap, &a->sender_USCOREdata);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__addSender(struct soap *soap, const struct ns2__addSender *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__addSender);
	if (soap_out_ns2__addSender(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__addSender(struct soap *soap, const char *tag, int id, const struct ns2__addSender *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__addSender), type))
		return soap->error;
	if (soap_out_string(soap, "login", -1, &a->login, ""))
		return soap->error;
	if (soap_out_string(soap, "api_pass", -1, &a->api_USCOREpass, ""))
		return soap->error;
	if (soap_out_PointerTons1__SenderData(soap, "sender_data", -1, &a->sender_USCOREdata, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "accept_terms", -1, &a->accept_USCOREterms, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__addSender * SOAP_FMAC4 soap_get_ns2__addSender(struct soap *soap, struct ns2__addSender *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__addSender(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns2__addSender * SOAP_FMAC4 soap_in_ns2__addSender(struct soap *soap, const char *tag, struct ns2__addSender *a, const char *type)
{
	size_t soap_flag_login = 1;
	size_t soap_flag_api_USCOREpass = 1;
	size_t soap_flag_sender_USCOREdata = 1;
	size_t soap_flag_accept_USCOREterms = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__addSender *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__addSender, sizeof(struct ns2__addSender), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__addSender(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_login && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "login", &a->login, "xsd:string"))
				{	soap_flag_login--;
					continue;
				}
			if (soap_flag_api_USCOREpass && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "api_pass", &a->api_USCOREpass, "xsd:string"))
				{	soap_flag_api_USCOREpass--;
					continue;
				}
			if (soap_flag_sender_USCOREdata && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__SenderData(soap, "sender_data", &a->sender_USCOREdata, "ns1:SenderData"))
				{	soap_flag_sender_USCOREdata--;
					continue;
				}
			if (soap_flag_accept_USCOREterms && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "accept_terms", &a->accept_USCOREterms, "xsd:boolean"))
				{	soap_flag_accept_USCOREterms--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__addSender *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__addSender, 0, sizeof(struct ns2__addSender), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_accept_USCOREterms > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__addSenderResponse(struct soap *soap, struct ns2__addSenderResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__addSenderResponse(struct soap *soap, const struct ns2__addSenderResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__AddSenderReturnObject(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__addSenderResponse(struct soap *soap, const struct ns2__addSenderResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__addSenderResponse);
	if (soap_out_ns2__addSenderResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__addSenderResponse(struct soap *soap, const char *tag, int id, const struct ns2__addSenderResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__addSenderResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__AddSenderReturnObject(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__addSenderResponse * SOAP_FMAC4 soap_get_ns2__addSenderResponse(struct soap *soap, struct ns2__addSenderResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__addSenderResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns2__addSenderResponse * SOAP_FMAC4 soap_in_ns2__addSenderResponse(struct soap *soap, const char *tag, struct ns2__addSenderResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__addSenderResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__addSenderResponse, sizeof(struct ns2__addSenderResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__addSenderResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__AddSenderReturnObject(soap, "return", &a->return_, "ns1:AddSenderReturnObject"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__addSenderResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__addSenderResponse, 0, sizeof(struct ns2__addSenderResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getPrice(struct soap *soap, struct ns2__getPrice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->login);
	soap_default_string(soap, &a->api_USCOREpass);
	soap_default_string(soap, &a->msg_USCOREtype);
	a->document_USCOREfiles = NULL;
	a->recipients = NULL;
	soap_default_int(soap, &a->config_USCOREid);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getPrice(struct soap *soap, const struct ns2__getPrice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->login);
	soap_serialize_string(soap, &a->api_USCOREpass);
	soap_serialize_string(soap, &a->msg_USCOREtype);
	soap_serialize_PointerToArrayOfDocumentFiles(soap, &a->document_USCOREfiles);
	soap_serialize_PointerToArrayOfRecipients(soap, &a->recipients);
	soap_embedded(soap, &a->config_USCOREid, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getPrice(struct soap *soap, const struct ns2__getPrice *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getPrice);
	if (soap_out_ns2__getPrice(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getPrice(struct soap *soap, const char *tag, int id, const struct ns2__getPrice *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getPrice), type))
		return soap->error;
	if (soap_out_string(soap, "login", -1, &a->login, ""))
		return soap->error;
	if (soap_out_string(soap, "api_pass", -1, &a->api_USCOREpass, ""))
		return soap->error;
	if (soap_out_string(soap, "msg_type", -1, &a->msg_USCOREtype, ""))
		return soap->error;
	if (soap_out_PointerToArrayOfDocumentFiles(soap, "document_files", -1, &a->document_USCOREfiles, ""))
		return soap->error;
	if (soap_out_PointerToArrayOfRecipients(soap, "recipients", -1, &a->recipients, ""))
		return soap->error;
	if (soap_out_int(soap, "config_id", -1, &a->config_USCOREid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getPrice * SOAP_FMAC4 soap_get_ns2__getPrice(struct soap *soap, struct ns2__getPrice *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getPrice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns2__getPrice * SOAP_FMAC4 soap_in_ns2__getPrice(struct soap *soap, const char *tag, struct ns2__getPrice *a, const char *type)
{
	size_t soap_flag_login = 1;
	size_t soap_flag_api_USCOREpass = 1;
	size_t soap_flag_msg_USCOREtype = 1;
	size_t soap_flag_document_USCOREfiles = 1;
	size_t soap_flag_recipients = 1;
	size_t soap_flag_config_USCOREid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__getPrice *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getPrice, sizeof(struct ns2__getPrice), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__getPrice(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_login && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "login", &a->login, "xsd:string"))
				{	soap_flag_login--;
					continue;
				}
			if (soap_flag_api_USCOREpass && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "api_pass", &a->api_USCOREpass, "xsd:string"))
				{	soap_flag_api_USCOREpass--;
					continue;
				}
			if (soap_flag_msg_USCOREtype && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "msg_type", &a->msg_USCOREtype, "xsd:string"))
				{	soap_flag_msg_USCOREtype--;
					continue;
				}
			if (soap_flag_document_USCOREfiles && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfDocumentFiles(soap, "document_files", &a->document_USCOREfiles, "ns1:DocumentFile"))
				{	soap_flag_document_USCOREfiles--;
					continue;
				}
			if (soap_flag_recipients && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfRecipients(soap, "recipients", &a->recipients, "ns1:Recipient"))
				{	soap_flag_recipients--;
					continue;
				}
			if (soap_flag_config_USCOREid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "config_id", &a->config_USCOREid, "xsd:int"))
				{	soap_flag_config_USCOREid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__getPrice *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getPrice, 0, sizeof(struct ns2__getPrice), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_config_USCOREid > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getPriceResponse(struct soap *soap, struct ns2__getPriceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getPriceResponse(struct soap *soap, const struct ns2__getPriceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__PriceReturnObject(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getPriceResponse(struct soap *soap, const struct ns2__getPriceResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getPriceResponse);
	if (soap_out_ns2__getPriceResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getPriceResponse(struct soap *soap, const char *tag, int id, const struct ns2__getPriceResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getPriceResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__PriceReturnObject(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getPriceResponse * SOAP_FMAC4 soap_get_ns2__getPriceResponse(struct soap *soap, struct ns2__getPriceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getPriceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns2__getPriceResponse * SOAP_FMAC4 soap_in_ns2__getPriceResponse(struct soap *soap, const char *tag, struct ns2__getPriceResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__getPriceResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getPriceResponse, sizeof(struct ns2__getPriceResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__getPriceResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__PriceReturnObject(soap, "return", &a->return_, "ns1:PriceReturnObject"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__getPriceResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getPriceResponse, 0, sizeof(struct ns2__getPriceResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getCertificate(struct soap *soap, struct ns2__getCertificate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->login);
	soap_default_string(soap, &a->api_USCOREpass);
	soap_default_string(soap, &a->dispatch_USCOREid);
	soap_default_int(soap, &a->certificate_USCOREtype);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getCertificate(struct soap *soap, const struct ns2__getCertificate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->login);
	soap_serialize_string(soap, &a->api_USCOREpass);
	soap_serialize_string(soap, &a->dispatch_USCOREid);
	soap_embedded(soap, &a->certificate_USCOREtype, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getCertificate(struct soap *soap, const struct ns2__getCertificate *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getCertificate);
	if (soap_out_ns2__getCertificate(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getCertificate(struct soap *soap, const char *tag, int id, const struct ns2__getCertificate *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getCertificate), type))
		return soap->error;
	if (soap_out_string(soap, "login", -1, &a->login, ""))
		return soap->error;
	if (soap_out_string(soap, "api_pass", -1, &a->api_USCOREpass, ""))
		return soap->error;
	if (soap_out_string(soap, "dispatch_id", -1, &a->dispatch_USCOREid, ""))
		return soap->error;
	if (soap_out_int(soap, "certificate_type", -1, &a->certificate_USCOREtype, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getCertificate * SOAP_FMAC4 soap_get_ns2__getCertificate(struct soap *soap, struct ns2__getCertificate *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getCertificate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns2__getCertificate * SOAP_FMAC4 soap_in_ns2__getCertificate(struct soap *soap, const char *tag, struct ns2__getCertificate *a, const char *type)
{
	size_t soap_flag_login = 1;
	size_t soap_flag_api_USCOREpass = 1;
	size_t soap_flag_dispatch_USCOREid = 1;
	size_t soap_flag_certificate_USCOREtype = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__getCertificate *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getCertificate, sizeof(struct ns2__getCertificate), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__getCertificate(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_login && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "login", &a->login, "xsd:string"))
				{	soap_flag_login--;
					continue;
				}
			if (soap_flag_api_USCOREpass && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "api_pass", &a->api_USCOREpass, "xsd:string"))
				{	soap_flag_api_USCOREpass--;
					continue;
				}
			if (soap_flag_dispatch_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "dispatch_id", &a->dispatch_USCOREid, "xsd:string"))
				{	soap_flag_dispatch_USCOREid--;
					continue;
				}
			if (soap_flag_certificate_USCOREtype && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "certificate_type", &a->certificate_USCOREtype, "xsd:int"))
				{	soap_flag_certificate_USCOREtype--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__getCertificate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getCertificate, 0, sizeof(struct ns2__getCertificate), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_certificate_USCOREtype > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getCertificateResponse(struct soap *soap, struct ns2__getCertificateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getCertificateResponse(struct soap *soap, const struct ns2__getCertificateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CertificateReturnObject(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getCertificateResponse(struct soap *soap, const struct ns2__getCertificateResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getCertificateResponse);
	if (soap_out_ns2__getCertificateResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getCertificateResponse(struct soap *soap, const char *tag, int id, const struct ns2__getCertificateResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getCertificateResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__CertificateReturnObject(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getCertificateResponse * SOAP_FMAC4 soap_get_ns2__getCertificateResponse(struct soap *soap, struct ns2__getCertificateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getCertificateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns2__getCertificateResponse * SOAP_FMAC4 soap_in_ns2__getCertificateResponse(struct soap *soap, const char *tag, struct ns2__getCertificateResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__getCertificateResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getCertificateResponse, sizeof(struct ns2__getCertificateResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__getCertificateResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CertificateReturnObject(soap, "return", &a->return_, "ns1:CertificateReturnObject"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__getCertificateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getCertificateResponse, 0, sizeof(struct ns2__getCertificateResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getSenders(struct soap *soap, struct ns2__getSenders *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->login);
	soap_default_string(soap, &a->api_USCOREpass);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getSenders(struct soap *soap, const struct ns2__getSenders *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->login);
	soap_serialize_string(soap, &a->api_USCOREpass);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getSenders(struct soap *soap, const struct ns2__getSenders *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getSenders);
	if (soap_out_ns2__getSenders(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getSenders(struct soap *soap, const char *tag, int id, const struct ns2__getSenders *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getSenders), type))
		return soap->error;
	if (soap_out_string(soap, "login", -1, &a->login, ""))
		return soap->error;
	if (soap_out_string(soap, "api_pass", -1, &a->api_USCOREpass, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getSenders * SOAP_FMAC4 soap_get_ns2__getSenders(struct soap *soap, struct ns2__getSenders *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getSenders(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns2__getSenders * SOAP_FMAC4 soap_in_ns2__getSenders(struct soap *soap, const char *tag, struct ns2__getSenders *a, const char *type)
{
	size_t soap_flag_login = 1;
	size_t soap_flag_api_USCOREpass = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__getSenders *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getSenders, sizeof(struct ns2__getSenders), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__getSenders(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_login && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "login", &a->login, "xsd:string"))
				{	soap_flag_login--;
					continue;
				}
			if (soap_flag_api_USCOREpass && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "api_pass", &a->api_USCOREpass, "xsd:string"))
				{	soap_flag_api_USCOREpass--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__getSenders *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getSenders, 0, sizeof(struct ns2__getSenders), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getSendersResponse(struct soap *soap, struct ns2__getSendersResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getSendersResponse(struct soap *soap, const struct ns2__getSendersResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__SendersReturnObject(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getSendersResponse(struct soap *soap, const struct ns2__getSendersResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getSendersResponse);
	if (soap_out_ns2__getSendersResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getSendersResponse(struct soap *soap, const char *tag, int id, const struct ns2__getSendersResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getSendersResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__SendersReturnObject(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getSendersResponse * SOAP_FMAC4 soap_get_ns2__getSendersResponse(struct soap *soap, struct ns2__getSendersResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getSendersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns2__getSendersResponse * SOAP_FMAC4 soap_in_ns2__getSendersResponse(struct soap *soap, const char *tag, struct ns2__getSendersResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__getSendersResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getSendersResponse, sizeof(struct ns2__getSendersResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__getSendersResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__SendersReturnObject(soap, "return", &a->return_, "ns1:SendersReturnObject"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__getSendersResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getSendersResponse, 0, sizeof(struct ns2__getSendersResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getConfigProfiles(struct soap *soap, struct ns2__getConfigProfiles *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->login);
	soap_default_string(soap, &a->api_USCOREpass);
	soap_default_string(soap, &a->msg_USCOREtype);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getConfigProfiles(struct soap *soap, const struct ns2__getConfigProfiles *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->login);
	soap_serialize_string(soap, &a->api_USCOREpass);
	soap_serialize_string(soap, &a->msg_USCOREtype);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getConfigProfiles(struct soap *soap, const struct ns2__getConfigProfiles *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getConfigProfiles);
	if (soap_out_ns2__getConfigProfiles(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getConfigProfiles(struct soap *soap, const char *tag, int id, const struct ns2__getConfigProfiles *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getConfigProfiles), type))
		return soap->error;
	if (soap_out_string(soap, "login", -1, &a->login, ""))
		return soap->error;
	if (soap_out_string(soap, "api_pass", -1, &a->api_USCOREpass, ""))
		return soap->error;
	if (soap_out_string(soap, "msg_type", -1, &a->msg_USCOREtype, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getConfigProfiles * SOAP_FMAC4 soap_get_ns2__getConfigProfiles(struct soap *soap, struct ns2__getConfigProfiles *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getConfigProfiles(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns2__getConfigProfiles * SOAP_FMAC4 soap_in_ns2__getConfigProfiles(struct soap *soap, const char *tag, struct ns2__getConfigProfiles *a, const char *type)
{
	size_t soap_flag_login = 1;
	size_t soap_flag_api_USCOREpass = 1;
	size_t soap_flag_msg_USCOREtype = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__getConfigProfiles *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getConfigProfiles, sizeof(struct ns2__getConfigProfiles), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__getConfigProfiles(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_login && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "login", &a->login, "xsd:string"))
				{	soap_flag_login--;
					continue;
				}
			if (soap_flag_api_USCOREpass && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "api_pass", &a->api_USCOREpass, "xsd:string"))
				{	soap_flag_api_USCOREpass--;
					continue;
				}
			if (soap_flag_msg_USCOREtype && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "msg_type", &a->msg_USCOREtype, "xsd:string"))
				{	soap_flag_msg_USCOREtype--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__getConfigProfiles *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getConfigProfiles, 0, sizeof(struct ns2__getConfigProfiles), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getConfigProfilesResponse(struct soap *soap, struct ns2__getConfigProfilesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getConfigProfilesResponse(struct soap *soap, const struct ns2__getConfigProfilesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ConfigProfilesReturnObject(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getConfigProfilesResponse(struct soap *soap, const struct ns2__getConfigProfilesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getConfigProfilesResponse);
	if (soap_out_ns2__getConfigProfilesResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getConfigProfilesResponse(struct soap *soap, const char *tag, int id, const struct ns2__getConfigProfilesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getConfigProfilesResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__ConfigProfilesReturnObject(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getConfigProfilesResponse * SOAP_FMAC4 soap_get_ns2__getConfigProfilesResponse(struct soap *soap, struct ns2__getConfigProfilesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getConfigProfilesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns2__getConfigProfilesResponse * SOAP_FMAC4 soap_in_ns2__getConfigProfilesResponse(struct soap *soap, const char *tag, struct ns2__getConfigProfilesResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__getConfigProfilesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getConfigProfilesResponse, sizeof(struct ns2__getConfigProfilesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__getConfigProfilesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ConfigProfilesReturnObject(soap, "return", &a->return_, "ns1:ConfigProfilesReturnObject"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__getConfigProfilesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getConfigProfilesResponse, 0, sizeof(struct ns2__getConfigProfilesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getBalance(struct soap *soap, struct ns2__getBalance *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->login);
	soap_default_string(soap, &a->api_USCOREpass);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getBalance(struct soap *soap, const struct ns2__getBalance *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->login);
	soap_serialize_string(soap, &a->api_USCOREpass);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getBalance(struct soap *soap, const struct ns2__getBalance *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getBalance);
	if (soap_out_ns2__getBalance(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getBalance(struct soap *soap, const char *tag, int id, const struct ns2__getBalance *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getBalance), type))
		return soap->error;
	if (soap_out_string(soap, "login", -1, &a->login, ""))
		return soap->error;
	if (soap_out_string(soap, "api_pass", -1, &a->api_USCOREpass, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getBalance * SOAP_FMAC4 soap_get_ns2__getBalance(struct soap *soap, struct ns2__getBalance *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getBalance(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns2__getBalance * SOAP_FMAC4 soap_in_ns2__getBalance(struct soap *soap, const char *tag, struct ns2__getBalance *a, const char *type)
{
	size_t soap_flag_login = 1;
	size_t soap_flag_api_USCOREpass = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__getBalance *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getBalance, sizeof(struct ns2__getBalance), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__getBalance(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_login && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "login", &a->login, "xsd:string"))
				{	soap_flag_login--;
					continue;
				}
			if (soap_flag_api_USCOREpass && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "api_pass", &a->api_USCOREpass, "xsd:string"))
				{	soap_flag_api_USCOREpass--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__getBalance *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getBalance, 0, sizeof(struct ns2__getBalance), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getBalanceResponse(struct soap *soap, struct ns2__getBalanceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getBalanceResponse(struct soap *soap, const struct ns2__getBalanceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__BalanceReturnObject(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getBalanceResponse(struct soap *soap, const struct ns2__getBalanceResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getBalanceResponse);
	if (soap_out_ns2__getBalanceResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getBalanceResponse(struct soap *soap, const char *tag, int id, const struct ns2__getBalanceResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getBalanceResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__BalanceReturnObject(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getBalanceResponse * SOAP_FMAC4 soap_get_ns2__getBalanceResponse(struct soap *soap, struct ns2__getBalanceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getBalanceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns2__getBalanceResponse * SOAP_FMAC4 soap_in_ns2__getBalanceResponse(struct soap *soap, const char *tag, struct ns2__getBalanceResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__getBalanceResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getBalanceResponse, sizeof(struct ns2__getBalanceResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__getBalanceResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__BalanceReturnObject(soap, "return", &a->return_, "ns1:BalanceReturnObject"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__getBalanceResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getBalanceResponse, 0, sizeof(struct ns2__getBalanceResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getDispatchStatus(struct soap *soap, struct ns2__getDispatchStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->login);
	soap_default_string(soap, &a->api_USCOREpass);
	a->dispatch_USCOREids = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getDispatchStatus(struct soap *soap, const struct ns2__getDispatchStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->login);
	soap_serialize_string(soap, &a->api_USCOREpass);
	soap_serialize_PointerToArrayOfDispatchIds(soap, &a->dispatch_USCOREids);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getDispatchStatus(struct soap *soap, const struct ns2__getDispatchStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getDispatchStatus);
	if (soap_out_ns2__getDispatchStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getDispatchStatus(struct soap *soap, const char *tag, int id, const struct ns2__getDispatchStatus *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getDispatchStatus), type))
		return soap->error;
	if (soap_out_string(soap, "login", -1, &a->login, ""))
		return soap->error;
	if (soap_out_string(soap, "api_pass", -1, &a->api_USCOREpass, ""))
		return soap->error;
	if (soap_out_PointerToArrayOfDispatchIds(soap, "dispatch_ids", -1, &a->dispatch_USCOREids, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getDispatchStatus * SOAP_FMAC4 soap_get_ns2__getDispatchStatus(struct soap *soap, struct ns2__getDispatchStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getDispatchStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns2__getDispatchStatus * SOAP_FMAC4 soap_in_ns2__getDispatchStatus(struct soap *soap, const char *tag, struct ns2__getDispatchStatus *a, const char *type)
{
	size_t soap_flag_login = 1;
	size_t soap_flag_api_USCOREpass = 1;
	size_t soap_flag_dispatch_USCOREids = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__getDispatchStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getDispatchStatus, sizeof(struct ns2__getDispatchStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__getDispatchStatus(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_login && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "login", &a->login, "xsd:string"))
				{	soap_flag_login--;
					continue;
				}
			if (soap_flag_api_USCOREpass && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "api_pass", &a->api_USCOREpass, "xsd:string"))
				{	soap_flag_api_USCOREpass--;
					continue;
				}
			if (soap_flag_dispatch_USCOREids && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfDispatchIds(soap, "dispatch_ids", &a->dispatch_USCOREids, "xsd:string"))
				{	soap_flag_dispatch_USCOREids--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__getDispatchStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getDispatchStatus, 0, sizeof(struct ns2__getDispatchStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getDispatchStatusResponse(struct soap *soap, struct ns2__getDispatchStatusResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getDispatchStatusResponse(struct soap *soap, const struct ns2__getDispatchStatusResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__DispatchReturnObject(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getDispatchStatusResponse(struct soap *soap, const struct ns2__getDispatchStatusResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getDispatchStatusResponse);
	if (soap_out_ns2__getDispatchStatusResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getDispatchStatusResponse(struct soap *soap, const char *tag, int id, const struct ns2__getDispatchStatusResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getDispatchStatusResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__DispatchReturnObject(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getDispatchStatusResponse * SOAP_FMAC4 soap_get_ns2__getDispatchStatusResponse(struct soap *soap, struct ns2__getDispatchStatusResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getDispatchStatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns2__getDispatchStatusResponse * SOAP_FMAC4 soap_in_ns2__getDispatchStatusResponse(struct soap *soap, const char *tag, struct ns2__getDispatchStatusResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__getDispatchStatusResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getDispatchStatusResponse, sizeof(struct ns2__getDispatchStatusResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__getDispatchStatusResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__DispatchReturnObject(soap, "return", &a->return_, "ns1:DispatchReturnObject"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__getDispatchStatusResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getDispatchStatusResponse, 0, sizeof(struct ns2__getDispatchStatusResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__dispatch(struct soap *soap, struct ns2__dispatch *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->login);
	soap_default_string(soap, &a->api_USCOREpass);
	soap_default_string(soap, &a->msg_USCOREtype);
	a->document_USCOREfiles = NULL;
	a->recipients = NULL;
	a->options = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__dispatch(struct soap *soap, const struct ns2__dispatch *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->login);
	soap_serialize_string(soap, &a->api_USCOREpass);
	soap_serialize_string(soap, &a->msg_USCOREtype);
	soap_serialize_PointerToArrayOfDocumentFiles(soap, &a->document_USCOREfiles);
	soap_serialize_PointerToArrayOfRecipients(soap, &a->recipients);
	soap_serialize_PointerToArrayOfOptions(soap, &a->options);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__dispatch(struct soap *soap, const struct ns2__dispatch *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__dispatch);
	if (soap_out_ns2__dispatch(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__dispatch(struct soap *soap, const char *tag, int id, const struct ns2__dispatch *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__dispatch), type))
		return soap->error;
	if (soap_out_string(soap, "login", -1, &a->login, ""))
		return soap->error;
	if (soap_out_string(soap, "api_pass", -1, &a->api_USCOREpass, ""))
		return soap->error;
	if (soap_out_string(soap, "msg_type", -1, &a->msg_USCOREtype, ""))
		return soap->error;
	if (soap_out_PointerToArrayOfDocumentFiles(soap, "document_files", -1, &a->document_USCOREfiles, ""))
		return soap->error;
	if (soap_out_PointerToArrayOfRecipients(soap, "recipients", -1, &a->recipients, ""))
		return soap->error;
	if (soap_out_PointerToArrayOfOptions(soap, "options", -1, &a->options, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__dispatch * SOAP_FMAC4 soap_get_ns2__dispatch(struct soap *soap, struct ns2__dispatch *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__dispatch(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns2__dispatch * SOAP_FMAC4 soap_in_ns2__dispatch(struct soap *soap, const char *tag, struct ns2__dispatch *a, const char *type)
{
	size_t soap_flag_login = 1;
	size_t soap_flag_api_USCOREpass = 1;
	size_t soap_flag_msg_USCOREtype = 1;
	size_t soap_flag_document_USCOREfiles = 1;
	size_t soap_flag_recipients = 1;
	size_t soap_flag_options = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__dispatch *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__dispatch, sizeof(struct ns2__dispatch), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__dispatch(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_login && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "login", &a->login, "xsd:string"))
				{	soap_flag_login--;
					continue;
				}
			if (soap_flag_api_USCOREpass && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "api_pass", &a->api_USCOREpass, "xsd:string"))
				{	soap_flag_api_USCOREpass--;
					continue;
				}
			if (soap_flag_msg_USCOREtype && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "msg_type", &a->msg_USCOREtype, "xsd:string"))
				{	soap_flag_msg_USCOREtype--;
					continue;
				}
			if (soap_flag_document_USCOREfiles && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfDocumentFiles(soap, "document_files", &a->document_USCOREfiles, "ns1:DocumentFile"))
				{	soap_flag_document_USCOREfiles--;
					continue;
				}
			if (soap_flag_recipients && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfRecipients(soap, "recipients", &a->recipients, "ns1:Recipient"))
				{	soap_flag_recipients--;
					continue;
				}
			if (soap_flag_options && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfOptions(soap, "options", &a->options, "ns1:Option"))
				{	soap_flag_options--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__dispatch *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__dispatch, 0, sizeof(struct ns2__dispatch), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__dispatchResponse(struct soap *soap, struct ns2__dispatchResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__dispatchResponse(struct soap *soap, const struct ns2__dispatchResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__DispatchReturnObject(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__dispatchResponse(struct soap *soap, const struct ns2__dispatchResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__dispatchResponse);
	if (soap_out_ns2__dispatchResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__dispatchResponse(struct soap *soap, const char *tag, int id, const struct ns2__dispatchResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__dispatchResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__DispatchReturnObject(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__dispatchResponse * SOAP_FMAC4 soap_get_ns2__dispatchResponse(struct soap *soap, struct ns2__dispatchResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__dispatchResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns2__dispatchResponse * SOAP_FMAC4 soap_in_ns2__dispatchResponse(struct soap *soap, const char *tag, struct ns2__dispatchResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__dispatchResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__dispatchResponse, sizeof(struct ns2__dispatchResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__dispatchResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__DispatchReturnObject(soap, "return", &a->return_, "ns1:DispatchReturnObject"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__dispatchResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__dispatchResponse, 0, sizeof(struct ns2__dispatchResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ArrayOfDispatchIds(struct soap *soap, struct ArrayOfDispatchIds *a)
{
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ArrayOfDispatchIds(struct soap *soap, struct ArrayOfDispatchIds const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_ArrayOfDispatchIds))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_string(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ArrayOfDispatchIds(struct soap *soap, const struct ArrayOfDispatchIds *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_ArrayOfDispatchIds);
	if (soap_out_ArrayOfDispatchIds(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfDispatchIds(struct soap *soap, const char *tag, int id, const struct ArrayOfDispatchIds *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsize(soap, "xsd:string", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfDispatchIds);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_string(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ArrayOfDispatchIds * SOAP_FMAC4 soap_get_ArrayOfDispatchIds(struct soap *soap, struct ArrayOfDispatchIds *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfDispatchIds(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ArrayOfDispatchIds * SOAP_FMAC4 soap_in_ArrayOfDispatchIds(struct soap *soap, const char *tag, struct ArrayOfDispatchIds *a, const char *type)
{	int i, j;
	char **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ArrayOfDispatchIds *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfDispatchIds, sizeof(struct ArrayOfDispatchIds), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ArrayOfDispatchIds(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (char **)soap_malloc(soap, sizeof(char *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_string(soap, NULL, a->__ptr + i, "xsd:string"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (char **)soap_push_block(soap, NULL, sizeof(char *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_string(soap, NULL, p, "xsd:string"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (char **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ArrayOfDispatchIds *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfDispatchIds, 0, sizeof(struct ArrayOfDispatchIds), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ArrayOfOptions(struct soap *soap, struct ArrayOfOptions *a)
{
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ArrayOfOptions(struct soap *soap, struct ArrayOfOptions const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_ArrayOfOptions))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerTons1__Option(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ArrayOfOptions(struct soap *soap, const struct ArrayOfOptions *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_ArrayOfOptions);
	if (soap_out_ArrayOfOptions(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfOptions(struct soap *soap, const char *tag, int id, const struct ArrayOfOptions *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsize(soap, "ns1:Option", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfOptions);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__Option(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ArrayOfOptions * SOAP_FMAC4 soap_get_ArrayOfOptions(struct soap *soap, struct ArrayOfOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ArrayOfOptions * SOAP_FMAC4 soap_in_ArrayOfOptions(struct soap *soap, const char *tag, struct ArrayOfOptions *a, const char *type)
{	int i, j;
	struct ns1__Option **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ArrayOfOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfOptions, sizeof(struct ArrayOfOptions), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ArrayOfOptions(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct ns1__Option **)soap_malloc(soap, sizeof(struct ns1__Option *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__Option(soap, NULL, a->__ptr + i, "ns1:Option"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct ns1__Option **)soap_push_block(soap, NULL, sizeof(struct ns1__Option *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__Option(soap, NULL, p, "ns1:Option"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct ns1__Option **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ArrayOfOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfOptions, 0, sizeof(struct ArrayOfOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ArrayOfRecipients(struct soap *soap, struct ArrayOfRecipients *a)
{
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ArrayOfRecipients(struct soap *soap, struct ArrayOfRecipients const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_ArrayOfRecipients))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerTons1__Recipient(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ArrayOfRecipients(struct soap *soap, const struct ArrayOfRecipients *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_ArrayOfRecipients);
	if (soap_out_ArrayOfRecipients(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfRecipients(struct soap *soap, const char *tag, int id, const struct ArrayOfRecipients *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsize(soap, "ns1:Recipient", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfRecipients);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__Recipient(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ArrayOfRecipients * SOAP_FMAC4 soap_get_ArrayOfRecipients(struct soap *soap, struct ArrayOfRecipients *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfRecipients(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ArrayOfRecipients * SOAP_FMAC4 soap_in_ArrayOfRecipients(struct soap *soap, const char *tag, struct ArrayOfRecipients *a, const char *type)
{	int i, j;
	struct ns1__Recipient **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ArrayOfRecipients *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfRecipients, sizeof(struct ArrayOfRecipients), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ArrayOfRecipients(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct ns1__Recipient **)soap_malloc(soap, sizeof(struct ns1__Recipient *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__Recipient(soap, NULL, a->__ptr + i, "ns1:Recipient"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct ns1__Recipient **)soap_push_block(soap, NULL, sizeof(struct ns1__Recipient *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__Recipient(soap, NULL, p, "ns1:Recipient"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct ns1__Recipient **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ArrayOfRecipients *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfRecipients, 0, sizeof(struct ArrayOfRecipients), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ArrayOfDocumentFiles(struct soap *soap, struct ArrayOfDocumentFiles *a)
{
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ArrayOfDocumentFiles(struct soap *soap, struct ArrayOfDocumentFiles const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_ArrayOfDocumentFiles))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerTons1__DocumentFile(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ArrayOfDocumentFiles(struct soap *soap, const struct ArrayOfDocumentFiles *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_ArrayOfDocumentFiles);
	if (soap_out_ArrayOfDocumentFiles(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfDocumentFiles(struct soap *soap, const char *tag, int id, const struct ArrayOfDocumentFiles *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsize(soap, "ns1:DocumentFile", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfDocumentFiles);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__DocumentFile(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ArrayOfDocumentFiles * SOAP_FMAC4 soap_get_ArrayOfDocumentFiles(struct soap *soap, struct ArrayOfDocumentFiles *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfDocumentFiles(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ArrayOfDocumentFiles * SOAP_FMAC4 soap_in_ArrayOfDocumentFiles(struct soap *soap, const char *tag, struct ArrayOfDocumentFiles *a, const char *type)
{	int i, j;
	struct ns1__DocumentFile **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ArrayOfDocumentFiles *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfDocumentFiles, sizeof(struct ArrayOfDocumentFiles), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ArrayOfDocumentFiles(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct ns1__DocumentFile **)soap_malloc(soap, sizeof(struct ns1__DocumentFile *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__DocumentFile(soap, NULL, a->__ptr + i, "ns1:DocumentFile"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct ns1__DocumentFile **)soap_push_block(soap, NULL, sizeof(struct ns1__DocumentFile *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__DocumentFile(soap, NULL, p, "ns1:DocumentFile"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct ns1__DocumentFile **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ArrayOfDocumentFiles *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfDocumentFiles, 0, sizeof(struct ArrayOfDocumentFiles), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__RemoveSenderReturnObject(struct soap *soap, struct ns1__RemoveSenderReturnObject *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->result);
	soap_default_string(soap, &a->result_USCOREcode);
	soap_default_string(soap, &a->result_USCOREdescription);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__RemoveSenderReturnObject(struct soap *soap, const struct ns1__RemoveSenderReturnObject *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->result);
	soap_serialize_string(soap, &a->result_USCOREcode);
	soap_serialize_string(soap, &a->result_USCOREdescription);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__RemoveSenderReturnObject(struct soap *soap, const struct ns1__RemoveSenderReturnObject *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__RemoveSenderReturnObject);
	if (soap_out_ns1__RemoveSenderReturnObject(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__RemoveSenderReturnObject(struct soap *soap, const char *tag, int id, const struct ns1__RemoveSenderReturnObject *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__RemoveSenderReturnObject), type))
		return soap->error;
	if (soap_out_string(soap, "result", -1, &a->result, ""))
		return soap->error;
	if (soap_out_string(soap, "result_code", -1, &a->result_USCOREcode, ""))
		return soap->error;
	if (soap_out_string(soap, "result_description", -1, &a->result_USCOREdescription, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__RemoveSenderReturnObject * SOAP_FMAC4 soap_get_ns1__RemoveSenderReturnObject(struct soap *soap, struct ns1__RemoveSenderReturnObject *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__RemoveSenderReturnObject(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__RemoveSenderReturnObject * SOAP_FMAC4 soap_in_ns1__RemoveSenderReturnObject(struct soap *soap, const char *tag, struct ns1__RemoveSenderReturnObject *a, const char *type)
{
	size_t soap_flag_result = 1;
	size_t soap_flag_result_USCOREcode = 1;
	size_t soap_flag_result_USCOREdescription = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__RemoveSenderReturnObject *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__RemoveSenderReturnObject, sizeof(struct ns1__RemoveSenderReturnObject), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__RemoveSenderReturnObject(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "result", &a->result, "xsd:string"))
				{	soap_flag_result--;
					continue;
				}
			if (soap_flag_result_USCOREcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "result_code", &a->result_USCOREcode, "xsd:string"))
				{	soap_flag_result_USCOREcode--;
					continue;
				}
			if (soap_flag_result_USCOREdescription && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "result_description", &a->result_USCOREdescription, "xsd:string"))
				{	soap_flag_result_USCOREdescription--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__RemoveSenderReturnObject *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__RemoveSenderReturnObject, 0, sizeof(struct ns1__RemoveSenderReturnObject), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0 || soap_flag_result_USCOREcode > 0 || soap_flag_result_USCOREdescription > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__VerifySenderReturnObject(struct soap *soap, struct ns1__VerifySenderReturnObject *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->result);
	soap_default_string(soap, &a->result_USCOREcode);
	soap_default_string(soap, &a->result_USCOREdescription);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__VerifySenderReturnObject(struct soap *soap, const struct ns1__VerifySenderReturnObject *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->result);
	soap_serialize_string(soap, &a->result_USCOREcode);
	soap_serialize_string(soap, &a->result_USCOREdescription);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__VerifySenderReturnObject(struct soap *soap, const struct ns1__VerifySenderReturnObject *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__VerifySenderReturnObject);
	if (soap_out_ns1__VerifySenderReturnObject(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__VerifySenderReturnObject(struct soap *soap, const char *tag, int id, const struct ns1__VerifySenderReturnObject *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__VerifySenderReturnObject), type))
		return soap->error;
	if (soap_out_string(soap, "result", -1, &a->result, ""))
		return soap->error;
	if (soap_out_string(soap, "result_code", -1, &a->result_USCOREcode, ""))
		return soap->error;
	if (soap_out_string(soap, "result_description", -1, &a->result_USCOREdescription, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__VerifySenderReturnObject * SOAP_FMAC4 soap_get_ns1__VerifySenderReturnObject(struct soap *soap, struct ns1__VerifySenderReturnObject *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__VerifySenderReturnObject(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__VerifySenderReturnObject * SOAP_FMAC4 soap_in_ns1__VerifySenderReturnObject(struct soap *soap, const char *tag, struct ns1__VerifySenderReturnObject *a, const char *type)
{
	size_t soap_flag_result = 1;
	size_t soap_flag_result_USCOREcode = 1;
	size_t soap_flag_result_USCOREdescription = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__VerifySenderReturnObject *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__VerifySenderReturnObject, sizeof(struct ns1__VerifySenderReturnObject), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__VerifySenderReturnObject(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "result", &a->result, "xsd:string"))
				{	soap_flag_result--;
					continue;
				}
			if (soap_flag_result_USCOREcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "result_code", &a->result_USCOREcode, "xsd:string"))
				{	soap_flag_result_USCOREcode--;
					continue;
				}
			if (soap_flag_result_USCOREdescription && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "result_description", &a->result_USCOREdescription, "xsd:string"))
				{	soap_flag_result_USCOREdescription--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__VerifySenderReturnObject *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__VerifySenderReturnObject, 0, sizeof(struct ns1__VerifySenderReturnObject), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0 || soap_flag_result_USCOREcode > 0 || soap_flag_result_USCOREdescription > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__AddSenderReturnObject(struct soap *soap, struct ns1__AddSenderReturnObject *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->result);
	soap_default_string(soap, &a->result_USCOREcode);
	soap_default_string(soap, &a->result_USCOREdescription);
	a->sender_USCOREid = NULL;
	soap_default_string(soap, &a->shipment_USCOREid);
	soap_default_string(soap, &a->sender_USCOREname);
	soap_default_string(soap, &a->sender_USCOREaddress);
	soap_default_string(soap, &a->sender_USCOREhome_USCOREnumber);
	soap_default_string(soap, &a->sender_USCOREflat_USCOREnumber);
	soap_default_string(soap, &a->sender_USCOREpost_USCOREcode);
	soap_default_string(soap, &a->sender_USCOREcity);
	soap_default_string(soap, &a->sender_USCOREcountry);
	soap_default_string(soap, &a->sender_USCOREfax_USCOREnumber);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__AddSenderReturnObject(struct soap *soap, const struct ns1__AddSenderReturnObject *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->result);
	soap_serialize_string(soap, &a->result_USCOREcode);
	soap_serialize_string(soap, &a->result_USCOREdescription);
	soap_serialize_PointerToint(soap, &a->sender_USCOREid);
	soap_serialize_string(soap, &a->shipment_USCOREid);
	soap_serialize_string(soap, &a->sender_USCOREname);
	soap_serialize_string(soap, &a->sender_USCOREaddress);
	soap_serialize_string(soap, &a->sender_USCOREhome_USCOREnumber);
	soap_serialize_string(soap, &a->sender_USCOREflat_USCOREnumber);
	soap_serialize_string(soap, &a->sender_USCOREpost_USCOREcode);
	soap_serialize_string(soap, &a->sender_USCOREcity);
	soap_serialize_string(soap, &a->sender_USCOREcountry);
	soap_serialize_string(soap, &a->sender_USCOREfax_USCOREnumber);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__AddSenderReturnObject(struct soap *soap, const struct ns1__AddSenderReturnObject *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__AddSenderReturnObject);
	if (soap_out_ns1__AddSenderReturnObject(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AddSenderReturnObject(struct soap *soap, const char *tag, int id, const struct ns1__AddSenderReturnObject *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__AddSenderReturnObject), type))
		return soap->error;
	if (soap_out_string(soap, "result", -1, &a->result, ""))
		return soap->error;
	if (soap_out_string(soap, "result_code", -1, &a->result_USCOREcode, ""))
		return soap->error;
	if (soap_out_string(soap, "result_description", -1, &a->result_USCOREdescription, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "sender_id", -1, &a->sender_USCOREid, ""))
		return soap->error;
	if (soap_out_string(soap, "shipment_id", -1, &a->shipment_USCOREid, ""))
		return soap->error;
	if (soap_out_string(soap, "sender_name", -1, &a->sender_USCOREname, ""))
		return soap->error;
	if (soap_out_string(soap, "sender_address", -1, &a->sender_USCOREaddress, ""))
		return soap->error;
	if (soap_out_string(soap, "sender_home_number", -1, &a->sender_USCOREhome_USCOREnumber, ""))
		return soap->error;
	if (soap_out_string(soap, "sender_flat_number", -1, &a->sender_USCOREflat_USCOREnumber, ""))
		return soap->error;
	if (soap_out_string(soap, "sender_post_code", -1, &a->sender_USCOREpost_USCOREcode, ""))
		return soap->error;
	if (soap_out_string(soap, "sender_city", -1, &a->sender_USCOREcity, ""))
		return soap->error;
	if (soap_out_string(soap, "sender_country", -1, &a->sender_USCOREcountry, ""))
		return soap->error;
	if (soap_out_string(soap, "sender_fax_number", -1, &a->sender_USCOREfax_USCOREnumber, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__AddSenderReturnObject * SOAP_FMAC4 soap_get_ns1__AddSenderReturnObject(struct soap *soap, struct ns1__AddSenderReturnObject *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__AddSenderReturnObject(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__AddSenderReturnObject * SOAP_FMAC4 soap_in_ns1__AddSenderReturnObject(struct soap *soap, const char *tag, struct ns1__AddSenderReturnObject *a, const char *type)
{
	size_t soap_flag_result = 1;
	size_t soap_flag_result_USCOREcode = 1;
	size_t soap_flag_result_USCOREdescription = 1;
	size_t soap_flag_sender_USCOREid = 1;
	size_t soap_flag_shipment_USCOREid = 1;
	size_t soap_flag_sender_USCOREname = 1;
	size_t soap_flag_sender_USCOREaddress = 1;
	size_t soap_flag_sender_USCOREhome_USCOREnumber = 1;
	size_t soap_flag_sender_USCOREflat_USCOREnumber = 1;
	size_t soap_flag_sender_USCOREpost_USCOREcode = 1;
	size_t soap_flag_sender_USCOREcity = 1;
	size_t soap_flag_sender_USCOREcountry = 1;
	size_t soap_flag_sender_USCOREfax_USCOREnumber = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__AddSenderReturnObject *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AddSenderReturnObject, sizeof(struct ns1__AddSenderReturnObject), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__AddSenderReturnObject(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "result", &a->result, "xsd:string"))
				{	soap_flag_result--;
					continue;
				}
			if (soap_flag_result_USCOREcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "result_code", &a->result_USCOREcode, "xsd:string"))
				{	soap_flag_result_USCOREcode--;
					continue;
				}
			if (soap_flag_result_USCOREdescription && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "result_description", &a->result_USCOREdescription, "xsd:string"))
				{	soap_flag_result_USCOREdescription--;
					continue;
				}
			if (soap_flag_sender_USCOREid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "sender_id", &a->sender_USCOREid, "xsd:int"))
				{	soap_flag_sender_USCOREid--;
					continue;
				}
			if (soap_flag_shipment_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "shipment_id", &a->shipment_USCOREid, "xsd:string"))
				{	soap_flag_shipment_USCOREid--;
					continue;
				}
			if (soap_flag_sender_USCOREname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "sender_name", &a->sender_USCOREname, "xsd:string"))
				{	soap_flag_sender_USCOREname--;
					continue;
				}
			if (soap_flag_sender_USCOREaddress && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "sender_address", &a->sender_USCOREaddress, "xsd:string"))
				{	soap_flag_sender_USCOREaddress--;
					continue;
				}
			if (soap_flag_sender_USCOREhome_USCOREnumber && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "sender_home_number", &a->sender_USCOREhome_USCOREnumber, "xsd:string"))
				{	soap_flag_sender_USCOREhome_USCOREnumber--;
					continue;
				}
			if (soap_flag_sender_USCOREflat_USCOREnumber && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "sender_flat_number", &a->sender_USCOREflat_USCOREnumber, "xsd:string"))
				{	soap_flag_sender_USCOREflat_USCOREnumber--;
					continue;
				}
			if (soap_flag_sender_USCOREpost_USCOREcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "sender_post_code", &a->sender_USCOREpost_USCOREcode, "xsd:string"))
				{	soap_flag_sender_USCOREpost_USCOREcode--;
					continue;
				}
			if (soap_flag_sender_USCOREcity && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "sender_city", &a->sender_USCOREcity, "xsd:string"))
				{	soap_flag_sender_USCOREcity--;
					continue;
				}
			if (soap_flag_sender_USCOREcountry && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "sender_country", &a->sender_USCOREcountry, "xsd:string"))
				{	soap_flag_sender_USCOREcountry--;
					continue;
				}
			if (soap_flag_sender_USCOREfax_USCOREnumber && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "sender_fax_number", &a->sender_USCOREfax_USCOREnumber, "xsd:string"))
				{	soap_flag_sender_USCOREfax_USCOREnumber--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__AddSenderReturnObject *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__AddSenderReturnObject, 0, sizeof(struct ns1__AddSenderReturnObject), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0 || soap_flag_result_USCOREcode > 0 || soap_flag_result_USCOREdescription > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ArrayOfShipmentsPrice(struct soap *soap, struct ArrayOfShipmentsPrice *a)
{
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ArrayOfShipmentsPrice(struct soap *soap, struct ArrayOfShipmentsPrice const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_ArrayOfShipmentsPrice))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerTons1__ShipmentPrice(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ArrayOfShipmentsPrice(struct soap *soap, const struct ArrayOfShipmentsPrice *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_ArrayOfShipmentsPrice);
	if (soap_out_ArrayOfShipmentsPrice(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfShipmentsPrice(struct soap *soap, const char *tag, int id, const struct ArrayOfShipmentsPrice *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsize(soap, "ns1:ShipmentPrice", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfShipmentsPrice);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__ShipmentPrice(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ArrayOfShipmentsPrice * SOAP_FMAC4 soap_get_ArrayOfShipmentsPrice(struct soap *soap, struct ArrayOfShipmentsPrice *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfShipmentsPrice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ArrayOfShipmentsPrice * SOAP_FMAC4 soap_in_ArrayOfShipmentsPrice(struct soap *soap, const char *tag, struct ArrayOfShipmentsPrice *a, const char *type)
{	int i, j;
	struct ns1__ShipmentPrice **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ArrayOfShipmentsPrice *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfShipmentsPrice, sizeof(struct ArrayOfShipmentsPrice), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ArrayOfShipmentsPrice(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct ns1__ShipmentPrice **)soap_malloc(soap, sizeof(struct ns1__ShipmentPrice *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__ShipmentPrice(soap, NULL, a->__ptr + i, "ns1:ShipmentPrice"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct ns1__ShipmentPrice **)soap_push_block(soap, NULL, sizeof(struct ns1__ShipmentPrice *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__ShipmentPrice(soap, NULL, p, "ns1:ShipmentPrice"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct ns1__ShipmentPrice **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ArrayOfShipmentsPrice *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfShipmentsPrice, 0, sizeof(struct ArrayOfShipmentsPrice), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__PriceReturnObject(struct soap *soap, struct ns1__PriceReturnObject *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->result);
	soap_default_string(soap, &a->result_USCOREcode);
	soap_default_string(soap, &a->result_USCOREdescription);
	a->shipments_USCOREprice = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__PriceReturnObject(struct soap *soap, const struct ns1__PriceReturnObject *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->result);
	soap_serialize_string(soap, &a->result_USCOREcode);
	soap_serialize_string(soap, &a->result_USCOREdescription);
	soap_serialize_PointerToArrayOfShipmentsPrice(soap, &a->shipments_USCOREprice);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__PriceReturnObject(struct soap *soap, const struct ns1__PriceReturnObject *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__PriceReturnObject);
	if (soap_out_ns1__PriceReturnObject(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__PriceReturnObject(struct soap *soap, const char *tag, int id, const struct ns1__PriceReturnObject *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__PriceReturnObject), type))
		return soap->error;
	if (soap_out_string(soap, "result", -1, &a->result, ""))
		return soap->error;
	if (soap_out_string(soap, "result_code", -1, &a->result_USCOREcode, ""))
		return soap->error;
	if (soap_out_string(soap, "result_description", -1, &a->result_USCOREdescription, ""))
		return soap->error;
	if (soap_out_PointerToArrayOfShipmentsPrice(soap, "shipments_price", -1, &a->shipments_USCOREprice, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__PriceReturnObject * SOAP_FMAC4 soap_get_ns1__PriceReturnObject(struct soap *soap, struct ns1__PriceReturnObject *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__PriceReturnObject(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__PriceReturnObject * SOAP_FMAC4 soap_in_ns1__PriceReturnObject(struct soap *soap, const char *tag, struct ns1__PriceReturnObject *a, const char *type)
{
	size_t soap_flag_result = 1;
	size_t soap_flag_result_USCOREcode = 1;
	size_t soap_flag_result_USCOREdescription = 1;
	size_t soap_flag_shipments_USCOREprice = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__PriceReturnObject *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__PriceReturnObject, sizeof(struct ns1__PriceReturnObject), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__PriceReturnObject(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "result", &a->result, "xsd:string"))
				{	soap_flag_result--;
					continue;
				}
			if (soap_flag_result_USCOREcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "result_code", &a->result_USCOREcode, "xsd:string"))
				{	soap_flag_result_USCOREcode--;
					continue;
				}
			if (soap_flag_result_USCOREdescription && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "result_description", &a->result_USCOREdescription, "xsd:string"))
				{	soap_flag_result_USCOREdescription--;
					continue;
				}
			if (soap_flag_shipments_USCOREprice && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfShipmentsPrice(soap, "shipments_price", &a->shipments_USCOREprice, "ns1:ShipmentPrice"))
				{	soap_flag_shipments_USCOREprice--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__PriceReturnObject *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__PriceReturnObject, 0, sizeof(struct ns1__PriceReturnObject), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0 || soap_flag_result_USCOREcode > 0 || soap_flag_result_USCOREdescription > 0 || soap_flag_shipments_USCOREprice > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__CertificateReturnObject(struct soap *soap, struct ns1__CertificateReturnObject *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->result);
	soap_default_string(soap, &a->result_USCOREcode);
	soap_default_string(soap, &a->result_USCOREdescription);
	soap_default_xsd__boolean(soap, &a->cert_USCOREavailable);
	soap_default_string(soap, &a->cert_USCOREcontent);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__CertificateReturnObject(struct soap *soap, const struct ns1__CertificateReturnObject *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->result);
	soap_serialize_string(soap, &a->result_USCOREcode);
	soap_serialize_string(soap, &a->result_USCOREdescription);
	soap_serialize_string(soap, &a->cert_USCOREcontent);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__CertificateReturnObject(struct soap *soap, const struct ns1__CertificateReturnObject *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__CertificateReturnObject);
	if (soap_out_ns1__CertificateReturnObject(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CertificateReturnObject(struct soap *soap, const char *tag, int id, const struct ns1__CertificateReturnObject *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CertificateReturnObject), type))
		return soap->error;
	if (soap_out_string(soap, "result", -1, &a->result, ""))
		return soap->error;
	if (soap_out_string(soap, "result_code", -1, &a->result_USCOREcode, ""))
		return soap->error;
	if (soap_out_string(soap, "result_description", -1, &a->result_USCOREdescription, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "cert_available", -1, &a->cert_USCOREavailable, ""))
		return soap->error;
	if (soap_out_string(soap, "cert_content", -1, &a->cert_USCOREcontent, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__CertificateReturnObject * SOAP_FMAC4 soap_get_ns1__CertificateReturnObject(struct soap *soap, struct ns1__CertificateReturnObject *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CertificateReturnObject(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__CertificateReturnObject * SOAP_FMAC4 soap_in_ns1__CertificateReturnObject(struct soap *soap, const char *tag, struct ns1__CertificateReturnObject *a, const char *type)
{
	size_t soap_flag_result = 1;
	size_t soap_flag_result_USCOREcode = 1;
	size_t soap_flag_result_USCOREdescription = 1;
	size_t soap_flag_cert_USCOREavailable = 1;
	size_t soap_flag_cert_USCOREcontent = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__CertificateReturnObject *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CertificateReturnObject, sizeof(struct ns1__CertificateReturnObject), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__CertificateReturnObject(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "result", &a->result, "xsd:string"))
				{	soap_flag_result--;
					continue;
				}
			if (soap_flag_result_USCOREcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "result_code", &a->result_USCOREcode, "xsd:string"))
				{	soap_flag_result_USCOREcode--;
					continue;
				}
			if (soap_flag_result_USCOREdescription && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "result_description", &a->result_USCOREdescription, "xsd:string"))
				{	soap_flag_result_USCOREdescription--;
					continue;
				}
			if (soap_flag_cert_USCOREavailable && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "cert_available", &a->cert_USCOREavailable, "xsd:boolean"))
				{	soap_flag_cert_USCOREavailable--;
					continue;
				}
			if (soap_flag_cert_USCOREcontent && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "cert_content", &a->cert_USCOREcontent, "xsd:string"))
				{	soap_flag_cert_USCOREcontent--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__CertificateReturnObject *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CertificateReturnObject, 0, sizeof(struct ns1__CertificateReturnObject), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0 || soap_flag_result_USCOREcode > 0 || soap_flag_result_USCOREdescription > 0 || soap_flag_cert_USCOREavailable > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ArrayOfSenders(struct soap *soap, struct ArrayOfSenders *a)
{
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ArrayOfSenders(struct soap *soap, struct ArrayOfSenders const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_ArrayOfSenders))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerTons1__Sender(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ArrayOfSenders(struct soap *soap, const struct ArrayOfSenders *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_ArrayOfSenders);
	if (soap_out_ArrayOfSenders(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfSenders(struct soap *soap, const char *tag, int id, const struct ArrayOfSenders *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsize(soap, "ns1:Sender", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfSenders);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__Sender(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ArrayOfSenders * SOAP_FMAC4 soap_get_ArrayOfSenders(struct soap *soap, struct ArrayOfSenders *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfSenders(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ArrayOfSenders * SOAP_FMAC4 soap_in_ArrayOfSenders(struct soap *soap, const char *tag, struct ArrayOfSenders *a, const char *type)
{	int i, j;
	struct ns1__Sender **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ArrayOfSenders *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfSenders, sizeof(struct ArrayOfSenders), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ArrayOfSenders(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct ns1__Sender **)soap_malloc(soap, sizeof(struct ns1__Sender *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__Sender(soap, NULL, a->__ptr + i, "ns1:Sender"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct ns1__Sender **)soap_push_block(soap, NULL, sizeof(struct ns1__Sender *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__Sender(soap, NULL, p, "ns1:Sender"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct ns1__Sender **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ArrayOfSenders *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfSenders, 0, sizeof(struct ArrayOfSenders), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SendersReturnObject(struct soap *soap, struct ns1__SendersReturnObject *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->result);
	soap_default_string(soap, &a->result_USCOREcode);
	soap_default_string(soap, &a->result_USCOREdescription);
	a->senders = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SendersReturnObject(struct soap *soap, const struct ns1__SendersReturnObject *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->result);
	soap_serialize_string(soap, &a->result_USCOREcode);
	soap_serialize_string(soap, &a->result_USCOREdescription);
	soap_serialize_PointerToArrayOfSenders(soap, &a->senders);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SendersReturnObject(struct soap *soap, const struct ns1__SendersReturnObject *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__SendersReturnObject);
	if (soap_out_ns1__SendersReturnObject(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SendersReturnObject(struct soap *soap, const char *tag, int id, const struct ns1__SendersReturnObject *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SendersReturnObject), type))
		return soap->error;
	if (soap_out_string(soap, "result", -1, &a->result, ""))
		return soap->error;
	if (soap_out_string(soap, "result_code", -1, &a->result_USCOREcode, ""))
		return soap->error;
	if (soap_out_string(soap, "result_description", -1, &a->result_USCOREdescription, ""))
		return soap->error;
	if (soap_out_PointerToArrayOfSenders(soap, "senders", -1, &a->senders, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SendersReturnObject * SOAP_FMAC4 soap_get_ns1__SendersReturnObject(struct soap *soap, struct ns1__SendersReturnObject *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SendersReturnObject(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__SendersReturnObject * SOAP_FMAC4 soap_in_ns1__SendersReturnObject(struct soap *soap, const char *tag, struct ns1__SendersReturnObject *a, const char *type)
{
	size_t soap_flag_result = 1;
	size_t soap_flag_result_USCOREcode = 1;
	size_t soap_flag_result_USCOREdescription = 1;
	size_t soap_flag_senders = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SendersReturnObject *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SendersReturnObject, sizeof(struct ns1__SendersReturnObject), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SendersReturnObject(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "result", &a->result, "xsd:string"))
				{	soap_flag_result--;
					continue;
				}
			if (soap_flag_result_USCOREcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "result_code", &a->result_USCOREcode, "xsd:string"))
				{	soap_flag_result_USCOREcode--;
					continue;
				}
			if (soap_flag_result_USCOREdescription && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "result_description", &a->result_USCOREdescription, "xsd:string"))
				{	soap_flag_result_USCOREdescription--;
					continue;
				}
			if (soap_flag_senders && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfSenders(soap, "senders", &a->senders, "ns1:Sender"))
				{	soap_flag_senders--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SendersReturnObject *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SendersReturnObject, 0, sizeof(struct ns1__SendersReturnObject), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0 || soap_flag_result_USCOREcode > 0 || soap_flag_result_USCOREdescription > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ArrayOfConfigProfiles(struct soap *soap, struct ArrayOfConfigProfiles *a)
{
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ArrayOfConfigProfiles(struct soap *soap, struct ArrayOfConfigProfiles const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_ArrayOfConfigProfiles))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerTons1__ConfigProfile(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ArrayOfConfigProfiles(struct soap *soap, const struct ArrayOfConfigProfiles *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_ArrayOfConfigProfiles);
	if (soap_out_ArrayOfConfigProfiles(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfConfigProfiles(struct soap *soap, const char *tag, int id, const struct ArrayOfConfigProfiles *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsize(soap, "ns1:ConfigProfile", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfConfigProfiles);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__ConfigProfile(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ArrayOfConfigProfiles * SOAP_FMAC4 soap_get_ArrayOfConfigProfiles(struct soap *soap, struct ArrayOfConfigProfiles *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfConfigProfiles(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ArrayOfConfigProfiles * SOAP_FMAC4 soap_in_ArrayOfConfigProfiles(struct soap *soap, const char *tag, struct ArrayOfConfigProfiles *a, const char *type)
{	int i, j;
	struct ns1__ConfigProfile **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ArrayOfConfigProfiles *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfConfigProfiles, sizeof(struct ArrayOfConfigProfiles), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ArrayOfConfigProfiles(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct ns1__ConfigProfile **)soap_malloc(soap, sizeof(struct ns1__ConfigProfile *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__ConfigProfile(soap, NULL, a->__ptr + i, "ns1:ConfigProfile"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct ns1__ConfigProfile **)soap_push_block(soap, NULL, sizeof(struct ns1__ConfigProfile *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__ConfigProfile(soap, NULL, p, "ns1:ConfigProfile"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct ns1__ConfigProfile **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ArrayOfConfigProfiles *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfConfigProfiles, 0, sizeof(struct ArrayOfConfigProfiles), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ConfigProfilesReturnObject(struct soap *soap, struct ns1__ConfigProfilesReturnObject *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->result);
	soap_default_string(soap, &a->result_USCOREcode);
	soap_default_string(soap, &a->result_USCOREdescription);
	a->config_USCOREprofiles = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ConfigProfilesReturnObject(struct soap *soap, const struct ns1__ConfigProfilesReturnObject *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->result);
	soap_serialize_string(soap, &a->result_USCOREcode);
	soap_serialize_string(soap, &a->result_USCOREdescription);
	soap_serialize_PointerToArrayOfConfigProfiles(soap, &a->config_USCOREprofiles);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ConfigProfilesReturnObject(struct soap *soap, const struct ns1__ConfigProfilesReturnObject *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__ConfigProfilesReturnObject);
	if (soap_out_ns1__ConfigProfilesReturnObject(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ConfigProfilesReturnObject(struct soap *soap, const char *tag, int id, const struct ns1__ConfigProfilesReturnObject *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ConfigProfilesReturnObject), type))
		return soap->error;
	if (soap_out_string(soap, "result", -1, &a->result, ""))
		return soap->error;
	if (soap_out_string(soap, "result_code", -1, &a->result_USCOREcode, ""))
		return soap->error;
	if (soap_out_string(soap, "result_description", -1, &a->result_USCOREdescription, ""))
		return soap->error;
	if (soap_out_PointerToArrayOfConfigProfiles(soap, "config_profiles", -1, &a->config_USCOREprofiles, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__ConfigProfilesReturnObject * SOAP_FMAC4 soap_get_ns1__ConfigProfilesReturnObject(struct soap *soap, struct ns1__ConfigProfilesReturnObject *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ConfigProfilesReturnObject(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__ConfigProfilesReturnObject * SOAP_FMAC4 soap_in_ns1__ConfigProfilesReturnObject(struct soap *soap, const char *tag, struct ns1__ConfigProfilesReturnObject *a, const char *type)
{
	size_t soap_flag_result = 1;
	size_t soap_flag_result_USCOREcode = 1;
	size_t soap_flag_result_USCOREdescription = 1;
	size_t soap_flag_config_USCOREprofiles = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__ConfigProfilesReturnObject *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ConfigProfilesReturnObject, sizeof(struct ns1__ConfigProfilesReturnObject), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__ConfigProfilesReturnObject(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "result", &a->result, "xsd:string"))
				{	soap_flag_result--;
					continue;
				}
			if (soap_flag_result_USCOREcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "result_code", &a->result_USCOREcode, "xsd:string"))
				{	soap_flag_result_USCOREcode--;
					continue;
				}
			if (soap_flag_result_USCOREdescription && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "result_description", &a->result_USCOREdescription, "xsd:string"))
				{	soap_flag_result_USCOREdescription--;
					continue;
				}
			if (soap_flag_config_USCOREprofiles && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfConfigProfiles(soap, "config_profiles", &a->config_USCOREprofiles, "ns1:ConfigProfile"))
				{	soap_flag_config_USCOREprofiles--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__ConfigProfilesReturnObject *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ConfigProfilesReturnObject, 0, sizeof(struct ns1__ConfigProfilesReturnObject), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0 || soap_flag_result_USCOREcode > 0 || soap_flag_result_USCOREdescription > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__BalanceReturnObject(struct soap *soap, struct ns1__BalanceReturnObject *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->result);
	soap_default_string(soap, &a->result_USCOREcode);
	soap_default_string(soap, &a->result_USCOREdescription);
	a->balance = NULL;
	a->limit = NULL;
	a->postpaid = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__BalanceReturnObject(struct soap *soap, const struct ns1__BalanceReturnObject *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->result);
	soap_serialize_string(soap, &a->result_USCOREcode);
	soap_serialize_string(soap, &a->result_USCOREdescription);
	soap_serialize_PointerTofloat(soap, &a->balance);
	soap_serialize_PointerTofloat(soap, &a->limit);
	soap_serialize_PointerToint(soap, &a->postpaid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__BalanceReturnObject(struct soap *soap, const struct ns1__BalanceReturnObject *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__BalanceReturnObject);
	if (soap_out_ns1__BalanceReturnObject(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__BalanceReturnObject(struct soap *soap, const char *tag, int id, const struct ns1__BalanceReturnObject *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__BalanceReturnObject), type))
		return soap->error;
	if (soap_out_string(soap, "result", -1, &a->result, ""))
		return soap->error;
	if (soap_out_string(soap, "result_code", -1, &a->result_USCOREcode, ""))
		return soap->error;
	if (soap_out_string(soap, "result_description", -1, &a->result_USCOREdescription, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "balance", -1, &a->balance, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "limit", -1, &a->limit, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "postpaid", -1, &a->postpaid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__BalanceReturnObject * SOAP_FMAC4 soap_get_ns1__BalanceReturnObject(struct soap *soap, struct ns1__BalanceReturnObject *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__BalanceReturnObject(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__BalanceReturnObject * SOAP_FMAC4 soap_in_ns1__BalanceReturnObject(struct soap *soap, const char *tag, struct ns1__BalanceReturnObject *a, const char *type)
{
	size_t soap_flag_result = 1;
	size_t soap_flag_result_USCOREcode = 1;
	size_t soap_flag_result_USCOREdescription = 1;
	size_t soap_flag_balance = 1;
	size_t soap_flag_limit = 1;
	size_t soap_flag_postpaid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__BalanceReturnObject *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__BalanceReturnObject, sizeof(struct ns1__BalanceReturnObject), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__BalanceReturnObject(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "result", &a->result, "xsd:string"))
				{	soap_flag_result--;
					continue;
				}
			if (soap_flag_result_USCOREcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "result_code", &a->result_USCOREcode, "xsd:string"))
				{	soap_flag_result_USCOREcode--;
					continue;
				}
			if (soap_flag_result_USCOREdescription && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "result_description", &a->result_USCOREdescription, "xsd:string"))
				{	soap_flag_result_USCOREdescription--;
					continue;
				}
			if (soap_flag_balance && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "balance", &a->balance, "xsd:float"))
				{	soap_flag_balance--;
					continue;
				}
			if (soap_flag_limit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "limit", &a->limit, "xsd:float"))
				{	soap_flag_limit--;
					continue;
				}
			if (soap_flag_postpaid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "postpaid", &a->postpaid, "xsd:int"))
				{	soap_flag_postpaid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__BalanceReturnObject *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__BalanceReturnObject, 0, sizeof(struct ns1__BalanceReturnObject), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0 || soap_flag_result_USCOREcode > 0 || soap_flag_result_USCOREdescription > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ArrayOfShipments(struct soap *soap, struct ArrayOfShipments *a)
{
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ArrayOfShipments(struct soap *soap, struct ArrayOfShipments const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_ArrayOfShipments))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerTons1__Shipment(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ArrayOfShipments(struct soap *soap, const struct ArrayOfShipments *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_ArrayOfShipments);
	if (soap_out_ArrayOfShipments(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfShipments(struct soap *soap, const char *tag, int id, const struct ArrayOfShipments *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsize(soap, "ns1:Shipment", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfShipments);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__Shipment(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ArrayOfShipments * SOAP_FMAC4 soap_get_ArrayOfShipments(struct soap *soap, struct ArrayOfShipments *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfShipments(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ArrayOfShipments * SOAP_FMAC4 soap_in_ArrayOfShipments(struct soap *soap, const char *tag, struct ArrayOfShipments *a, const char *type)
{	int i, j;
	struct ns1__Shipment **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ArrayOfShipments *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfShipments, sizeof(struct ArrayOfShipments), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ArrayOfShipments(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct ns1__Shipment **)soap_malloc(soap, sizeof(struct ns1__Shipment *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__Shipment(soap, NULL, a->__ptr + i, "ns1:Shipment"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct ns1__Shipment **)soap_push_block(soap, NULL, sizeof(struct ns1__Shipment *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__Shipment(soap, NULL, p, "ns1:Shipment"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct ns1__Shipment **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ArrayOfShipments *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfShipments, 0, sizeof(struct ArrayOfShipments), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__DispatchReturnObject(struct soap *soap, struct ns1__DispatchReturnObject *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->result);
	soap_default_string(soap, &a->result_USCOREcode);
	soap_default_string(soap, &a->result_USCOREdescription);
	a->shipments = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__DispatchReturnObject(struct soap *soap, const struct ns1__DispatchReturnObject *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->result);
	soap_serialize_string(soap, &a->result_USCOREcode);
	soap_serialize_string(soap, &a->result_USCOREdescription);
	soap_serialize_PointerToArrayOfShipments(soap, &a->shipments);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__DispatchReturnObject(struct soap *soap, const struct ns1__DispatchReturnObject *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__DispatchReturnObject);
	if (soap_out_ns1__DispatchReturnObject(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DispatchReturnObject(struct soap *soap, const char *tag, int id, const struct ns1__DispatchReturnObject *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DispatchReturnObject), type))
		return soap->error;
	if (soap_out_string(soap, "result", -1, &a->result, ""))
		return soap->error;
	if (soap_out_string(soap, "result_code", -1, &a->result_USCOREcode, ""))
		return soap->error;
	if (soap_out_string(soap, "result_description", -1, &a->result_USCOREdescription, ""))
		return soap->error;
	if (soap_out_PointerToArrayOfShipments(soap, "shipments", -1, &a->shipments, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__DispatchReturnObject * SOAP_FMAC4 soap_get_ns1__DispatchReturnObject(struct soap *soap, struct ns1__DispatchReturnObject *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DispatchReturnObject(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__DispatchReturnObject * SOAP_FMAC4 soap_in_ns1__DispatchReturnObject(struct soap *soap, const char *tag, struct ns1__DispatchReturnObject *a, const char *type)
{
	size_t soap_flag_result = 1;
	size_t soap_flag_result_USCOREcode = 1;
	size_t soap_flag_result_USCOREdescription = 1;
	size_t soap_flag_shipments = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__DispatchReturnObject *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DispatchReturnObject, sizeof(struct ns1__DispatchReturnObject), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__DispatchReturnObject(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "result", &a->result, "xsd:string"))
				{	soap_flag_result--;
					continue;
				}
			if (soap_flag_result_USCOREcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "result_code", &a->result_USCOREcode, "xsd:string"))
				{	soap_flag_result_USCOREcode--;
					continue;
				}
			if (soap_flag_result_USCOREdescription && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "result_description", &a->result_USCOREdescription, "xsd:string"))
				{	soap_flag_result_USCOREdescription--;
					continue;
				}
			if (soap_flag_shipments && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfShipments(soap, "shipments", &a->shipments, "ns1:Shipment"))
				{	soap_flag_shipments--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__DispatchReturnObject *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DispatchReturnObject, 0, sizeof(struct ns1__DispatchReturnObject), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0 || soap_flag_result_USCOREcode > 0 || soap_flag_result_USCOREdescription > 0 || soap_flag_shipments > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SenderData(struct soap *soap, struct ns1__SenderData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->sender_USCOREname);
	soap_default_string(soap, &a->sender_USCOREaddress_USCOREprefix);
	soap_default_string(soap, &a->sender_USCOREaddress);
	soap_default_string(soap, &a->sender_USCOREhome_USCOREnumber);
	soap_default_string(soap, &a->sender_USCOREflat_USCOREnumber);
	soap_default_string(soap, &a->sender_USCOREpost_USCOREcode);
	soap_default_string(soap, &a->sender_USCOREcity);
	soap_default_string(soap, &a->sender_USCOREcountry);
	soap_default_string(soap, &a->sender_USCOREfax_USCOREnumber);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SenderData(struct soap *soap, const struct ns1__SenderData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->sender_USCOREname);
	soap_serialize_string(soap, &a->sender_USCOREaddress_USCOREprefix);
	soap_serialize_string(soap, &a->sender_USCOREaddress);
	soap_serialize_string(soap, &a->sender_USCOREhome_USCOREnumber);
	soap_serialize_string(soap, &a->sender_USCOREflat_USCOREnumber);
	soap_serialize_string(soap, &a->sender_USCOREpost_USCOREcode);
	soap_serialize_string(soap, &a->sender_USCOREcity);
	soap_serialize_string(soap, &a->sender_USCOREcountry);
	soap_serialize_string(soap, &a->sender_USCOREfax_USCOREnumber);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SenderData(struct soap *soap, const struct ns1__SenderData *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__SenderData);
	if (soap_out_ns1__SenderData(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SenderData(struct soap *soap, const char *tag, int id, const struct ns1__SenderData *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SenderData), type))
		return soap->error;
	if (soap_out_string(soap, "sender_name", -1, &a->sender_USCOREname, ""))
		return soap->error;
	if (soap_out_string(soap, "sender_address_prefix", -1, &a->sender_USCOREaddress_USCOREprefix, ""))
		return soap->error;
	if (soap_out_string(soap, "sender_address", -1, &a->sender_USCOREaddress, ""))
		return soap->error;
	if (soap_out_string(soap, "sender_home_number", -1, &a->sender_USCOREhome_USCOREnumber, ""))
		return soap->error;
	if (soap_out_string(soap, "sender_flat_number", -1, &a->sender_USCOREflat_USCOREnumber, ""))
		return soap->error;
	if (soap_out_string(soap, "sender_post_code", -1, &a->sender_USCOREpost_USCOREcode, ""))
		return soap->error;
	if (soap_out_string(soap, "sender_city", -1, &a->sender_USCOREcity, ""))
		return soap->error;
	if (soap_out_string(soap, "sender_country", -1, &a->sender_USCOREcountry, ""))
		return soap->error;
	if (soap_out_string(soap, "sender_fax_number", -1, &a->sender_USCOREfax_USCOREnumber, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SenderData * SOAP_FMAC4 soap_get_ns1__SenderData(struct soap *soap, struct ns1__SenderData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SenderData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__SenderData * SOAP_FMAC4 soap_in_ns1__SenderData(struct soap *soap, const char *tag, struct ns1__SenderData *a, const char *type)
{
	size_t soap_flag_sender_USCOREname = 1;
	size_t soap_flag_sender_USCOREaddress_USCOREprefix = 1;
	size_t soap_flag_sender_USCOREaddress = 1;
	size_t soap_flag_sender_USCOREhome_USCOREnumber = 1;
	size_t soap_flag_sender_USCOREflat_USCOREnumber = 1;
	size_t soap_flag_sender_USCOREpost_USCOREcode = 1;
	size_t soap_flag_sender_USCOREcity = 1;
	size_t soap_flag_sender_USCOREcountry = 1;
	size_t soap_flag_sender_USCOREfax_USCOREnumber = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SenderData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SenderData, sizeof(struct ns1__SenderData), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SenderData(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sender_USCOREname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "sender_name", &a->sender_USCOREname, "xsd:string"))
				{	soap_flag_sender_USCOREname--;
					continue;
				}
			if (soap_flag_sender_USCOREaddress_USCOREprefix && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "sender_address_prefix", &a->sender_USCOREaddress_USCOREprefix, "xsd:string"))
				{	soap_flag_sender_USCOREaddress_USCOREprefix--;
					continue;
				}
			if (soap_flag_sender_USCOREaddress && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "sender_address", &a->sender_USCOREaddress, "xsd:string"))
				{	soap_flag_sender_USCOREaddress--;
					continue;
				}
			if (soap_flag_sender_USCOREhome_USCOREnumber && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "sender_home_number", &a->sender_USCOREhome_USCOREnumber, "xsd:string"))
				{	soap_flag_sender_USCOREhome_USCOREnumber--;
					continue;
				}
			if (soap_flag_sender_USCOREflat_USCOREnumber && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "sender_flat_number", &a->sender_USCOREflat_USCOREnumber, "xsd:string"))
				{	soap_flag_sender_USCOREflat_USCOREnumber--;
					continue;
				}
			if (soap_flag_sender_USCOREpost_USCOREcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "sender_post_code", &a->sender_USCOREpost_USCOREcode, "xsd:string"))
				{	soap_flag_sender_USCOREpost_USCOREcode--;
					continue;
				}
			if (soap_flag_sender_USCOREcity && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "sender_city", &a->sender_USCOREcity, "xsd:string"))
				{	soap_flag_sender_USCOREcity--;
					continue;
				}
			if (soap_flag_sender_USCOREcountry && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "sender_country", &a->sender_USCOREcountry, "xsd:string"))
				{	soap_flag_sender_USCOREcountry--;
					continue;
				}
			if (soap_flag_sender_USCOREfax_USCOREnumber && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "sender_fax_number", &a->sender_USCOREfax_USCOREnumber, "xsd:string"))
				{	soap_flag_sender_USCOREfax_USCOREnumber--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SenderData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SenderData, 0, sizeof(struct ns1__SenderData), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ShipmentPrice(struct soap *soap, struct ns1__ShipmentPrice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->recipient_USCOREname);
	soap_default_string(soap, &a->recipient_USCOREaddress);
	soap_default_string(soap, &a->recipient_USCOREhome_USCOREnumber);
	soap_default_string(soap, &a->recipient_USCOREflat_USCOREnumber);
	soap_default_string(soap, &a->recipient_USCOREpost_USCOREcode);
	soap_default_string(soap, &a->recipient_USCOREcity);
	soap_default_string(soap, &a->recipient_USCOREcountry);
	soap_default_string(soap, &a->recipient_USCOREfax_USCOREnumber);
	soap_default_string(soap, &a->dispatch_USCOREcarrier);
	soap_default_string(soap, &a->dispatch_USCOREtype);
	a->page_USCOREnumber = NULL;
	a->price = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ShipmentPrice(struct soap *soap, const struct ns1__ShipmentPrice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->recipient_USCOREname);
	soap_serialize_string(soap, &a->recipient_USCOREaddress);
	soap_serialize_string(soap, &a->recipient_USCOREhome_USCOREnumber);
	soap_serialize_string(soap, &a->recipient_USCOREflat_USCOREnumber);
	soap_serialize_string(soap, &a->recipient_USCOREpost_USCOREcode);
	soap_serialize_string(soap, &a->recipient_USCOREcity);
	soap_serialize_string(soap, &a->recipient_USCOREcountry);
	soap_serialize_string(soap, &a->recipient_USCOREfax_USCOREnumber);
	soap_serialize_string(soap, &a->dispatch_USCOREcarrier);
	soap_serialize_string(soap, &a->dispatch_USCOREtype);
	soap_serialize_PointerToint(soap, &a->page_USCOREnumber);
	soap_serialize_PointerTofloat(soap, &a->price);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ShipmentPrice(struct soap *soap, const struct ns1__ShipmentPrice *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__ShipmentPrice);
	if (soap_out_ns1__ShipmentPrice(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ShipmentPrice(struct soap *soap, const char *tag, int id, const struct ns1__ShipmentPrice *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ShipmentPrice), type))
		return soap->error;
	if (soap_out_string(soap, "recipient_name", -1, &a->recipient_USCOREname, ""))
		return soap->error;
	if (soap_out_string(soap, "recipient_address", -1, &a->recipient_USCOREaddress, ""))
		return soap->error;
	if (soap_out_string(soap, "recipient_home_number", -1, &a->recipient_USCOREhome_USCOREnumber, ""))
		return soap->error;
	if (soap_out_string(soap, "recipient_flat_number", -1, &a->recipient_USCOREflat_USCOREnumber, ""))
		return soap->error;
	if (soap_out_string(soap, "recipient_post_code", -1, &a->recipient_USCOREpost_USCOREcode, ""))
		return soap->error;
	if (soap_out_string(soap, "recipient_city", -1, &a->recipient_USCOREcity, ""))
		return soap->error;
	if (soap_out_string(soap, "recipient_country", -1, &a->recipient_USCOREcountry, ""))
		return soap->error;
	if (soap_out_string(soap, "recipient_fax_number", -1, &a->recipient_USCOREfax_USCOREnumber, ""))
		return soap->error;
	if (soap_out_string(soap, "dispatch_carrier", -1, &a->dispatch_USCOREcarrier, ""))
		return soap->error;
	if (soap_out_string(soap, "dispatch_type", -1, &a->dispatch_USCOREtype, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "page_number", -1, &a->page_USCOREnumber, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "price", -1, &a->price, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__ShipmentPrice * SOAP_FMAC4 soap_get_ns1__ShipmentPrice(struct soap *soap, struct ns1__ShipmentPrice *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ShipmentPrice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__ShipmentPrice * SOAP_FMAC4 soap_in_ns1__ShipmentPrice(struct soap *soap, const char *tag, struct ns1__ShipmentPrice *a, const char *type)
{
	size_t soap_flag_recipient_USCOREname = 1;
	size_t soap_flag_recipient_USCOREaddress = 1;
	size_t soap_flag_recipient_USCOREhome_USCOREnumber = 1;
	size_t soap_flag_recipient_USCOREflat_USCOREnumber = 1;
	size_t soap_flag_recipient_USCOREpost_USCOREcode = 1;
	size_t soap_flag_recipient_USCOREcity = 1;
	size_t soap_flag_recipient_USCOREcountry = 1;
	size_t soap_flag_recipient_USCOREfax_USCOREnumber = 1;
	size_t soap_flag_dispatch_USCOREcarrier = 1;
	size_t soap_flag_dispatch_USCOREtype = 1;
	size_t soap_flag_page_USCOREnumber = 1;
	size_t soap_flag_price = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__ShipmentPrice *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ShipmentPrice, sizeof(struct ns1__ShipmentPrice), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__ShipmentPrice(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recipient_USCOREname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "recipient_name", &a->recipient_USCOREname, "xsd:string"))
				{	soap_flag_recipient_USCOREname--;
					continue;
				}
			if (soap_flag_recipient_USCOREaddress && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "recipient_address", &a->recipient_USCOREaddress, "xsd:string"))
				{	soap_flag_recipient_USCOREaddress--;
					continue;
				}
			if (soap_flag_recipient_USCOREhome_USCOREnumber && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "recipient_home_number", &a->recipient_USCOREhome_USCOREnumber, "xsd:string"))
				{	soap_flag_recipient_USCOREhome_USCOREnumber--;
					continue;
				}
			if (soap_flag_recipient_USCOREflat_USCOREnumber && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "recipient_flat_number", &a->recipient_USCOREflat_USCOREnumber, "xsd:string"))
				{	soap_flag_recipient_USCOREflat_USCOREnumber--;
					continue;
				}
			if (soap_flag_recipient_USCOREpost_USCOREcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "recipient_post_code", &a->recipient_USCOREpost_USCOREcode, "xsd:string"))
				{	soap_flag_recipient_USCOREpost_USCOREcode--;
					continue;
				}
			if (soap_flag_recipient_USCOREcity && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "recipient_city", &a->recipient_USCOREcity, "xsd:string"))
				{	soap_flag_recipient_USCOREcity--;
					continue;
				}
			if (soap_flag_recipient_USCOREcountry && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "recipient_country", &a->recipient_USCOREcountry, "xsd:string"))
				{	soap_flag_recipient_USCOREcountry--;
					continue;
				}
			if (soap_flag_recipient_USCOREfax_USCOREnumber && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "recipient_fax_number", &a->recipient_USCOREfax_USCOREnumber, "xsd:string"))
				{	soap_flag_recipient_USCOREfax_USCOREnumber--;
					continue;
				}
			if (soap_flag_dispatch_USCOREcarrier && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "dispatch_carrier", &a->dispatch_USCOREcarrier, "xsd:string"))
				{	soap_flag_dispatch_USCOREcarrier--;
					continue;
				}
			if (soap_flag_dispatch_USCOREtype && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "dispatch_type", &a->dispatch_USCOREtype, "xsd:string"))
				{	soap_flag_dispatch_USCOREtype--;
					continue;
				}
			if (soap_flag_page_USCOREnumber && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "page_number", &a->page_USCOREnumber, "xsd:int"))
				{	soap_flag_page_USCOREnumber--;
					continue;
				}
			if (soap_flag_price && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "price", &a->price, "xsd:float"))
				{	soap_flag_price--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__ShipmentPrice *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ShipmentPrice, 0, sizeof(struct ns1__ShipmentPrice), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__Sender(struct soap *soap, struct ns1__Sender *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->sender_USCOREid = NULL;
	soap_default_string(soap, &a->sender_USCOREname);
	soap_default_string(soap, &a->sender_USCOREaddress);
	soap_default_string(soap, &a->sender_USCOREhome_USCOREnumber);
	soap_default_string(soap, &a->sender_USCOREflat_USCOREnumber);
	soap_default_string(soap, &a->sender_USCOREpost_USCOREcode);
	soap_default_string(soap, &a->sender_USCOREcity);
	soap_default_string(soap, &a->sender_USCOREcountry);
	soap_default_string(soap, &a->sender_USCOREfax_USCOREnumber);
	soap_default_string(soap, &a->default_);
	soap_default_string(soap, &a->active);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__Sender(struct soap *soap, const struct ns1__Sender *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->sender_USCOREid);
	soap_serialize_string(soap, &a->sender_USCOREname);
	soap_serialize_string(soap, &a->sender_USCOREaddress);
	soap_serialize_string(soap, &a->sender_USCOREhome_USCOREnumber);
	soap_serialize_string(soap, &a->sender_USCOREflat_USCOREnumber);
	soap_serialize_string(soap, &a->sender_USCOREpost_USCOREcode);
	soap_serialize_string(soap, &a->sender_USCOREcity);
	soap_serialize_string(soap, &a->sender_USCOREcountry);
	soap_serialize_string(soap, &a->sender_USCOREfax_USCOREnumber);
	soap_serialize_string(soap, &a->default_);
	soap_serialize_string(soap, &a->active);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__Sender(struct soap *soap, const struct ns1__Sender *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__Sender);
	if (soap_out_ns1__Sender(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Sender(struct soap *soap, const char *tag, int id, const struct ns1__Sender *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Sender), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "sender_id", -1, &a->sender_USCOREid, ""))
		return soap->error;
	if (soap_out_string(soap, "sender_name", -1, &a->sender_USCOREname, ""))
		return soap->error;
	if (soap_out_string(soap, "sender_address", -1, &a->sender_USCOREaddress, ""))
		return soap->error;
	if (soap_out_string(soap, "sender_home_number", -1, &a->sender_USCOREhome_USCOREnumber, ""))
		return soap->error;
	if (soap_out_string(soap, "sender_flat_number", -1, &a->sender_USCOREflat_USCOREnumber, ""))
		return soap->error;
	if (soap_out_string(soap, "sender_post_code", -1, &a->sender_USCOREpost_USCOREcode, ""))
		return soap->error;
	if (soap_out_string(soap, "sender_city", -1, &a->sender_USCOREcity, ""))
		return soap->error;
	if (soap_out_string(soap, "sender_country", -1, &a->sender_USCOREcountry, ""))
		return soap->error;
	if (soap_out_string(soap, "sender_fax_number", -1, &a->sender_USCOREfax_USCOREnumber, ""))
		return soap->error;
	if (soap_out_string(soap, "default", -1, &a->default_, ""))
		return soap->error;
	if (soap_out_string(soap, "active", -1, &a->active, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__Sender * SOAP_FMAC4 soap_get_ns1__Sender(struct soap *soap, struct ns1__Sender *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Sender(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__Sender * SOAP_FMAC4 soap_in_ns1__Sender(struct soap *soap, const char *tag, struct ns1__Sender *a, const char *type)
{
	size_t soap_flag_sender_USCOREid = 1;
	size_t soap_flag_sender_USCOREname = 1;
	size_t soap_flag_sender_USCOREaddress = 1;
	size_t soap_flag_sender_USCOREhome_USCOREnumber = 1;
	size_t soap_flag_sender_USCOREflat_USCOREnumber = 1;
	size_t soap_flag_sender_USCOREpost_USCOREcode = 1;
	size_t soap_flag_sender_USCOREcity = 1;
	size_t soap_flag_sender_USCOREcountry = 1;
	size_t soap_flag_sender_USCOREfax_USCOREnumber = 1;
	size_t soap_flag_default_ = 1;
	size_t soap_flag_active = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__Sender *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Sender, sizeof(struct ns1__Sender), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__Sender(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sender_USCOREid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "sender_id", &a->sender_USCOREid, "xsd:int"))
				{	soap_flag_sender_USCOREid--;
					continue;
				}
			if (soap_flag_sender_USCOREname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "sender_name", &a->sender_USCOREname, "xsd:string"))
				{	soap_flag_sender_USCOREname--;
					continue;
				}
			if (soap_flag_sender_USCOREaddress && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "sender_address", &a->sender_USCOREaddress, "xsd:string"))
				{	soap_flag_sender_USCOREaddress--;
					continue;
				}
			if (soap_flag_sender_USCOREhome_USCOREnumber && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "sender_home_number", &a->sender_USCOREhome_USCOREnumber, "xsd:string"))
				{	soap_flag_sender_USCOREhome_USCOREnumber--;
					continue;
				}
			if (soap_flag_sender_USCOREflat_USCOREnumber && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "sender_flat_number", &a->sender_USCOREflat_USCOREnumber, "xsd:string"))
				{	soap_flag_sender_USCOREflat_USCOREnumber--;
					continue;
				}
			if (soap_flag_sender_USCOREpost_USCOREcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "sender_post_code", &a->sender_USCOREpost_USCOREcode, "xsd:string"))
				{	soap_flag_sender_USCOREpost_USCOREcode--;
					continue;
				}
			if (soap_flag_sender_USCOREcity && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "sender_city", &a->sender_USCOREcity, "xsd:string"))
				{	soap_flag_sender_USCOREcity--;
					continue;
				}
			if (soap_flag_sender_USCOREcountry && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "sender_country", &a->sender_USCOREcountry, "xsd:string"))
				{	soap_flag_sender_USCOREcountry--;
					continue;
				}
			if (soap_flag_sender_USCOREfax_USCOREnumber && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "sender_fax_number", &a->sender_USCOREfax_USCOREnumber, "xsd:string"))
				{	soap_flag_sender_USCOREfax_USCOREnumber--;
					continue;
				}
			if (soap_flag_default_ && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "default", &a->default_, "xsd:string"))
				{	soap_flag_default_--;
					continue;
				}
			if (soap_flag_active && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "active", &a->active, "xsd:string"))
				{	soap_flag_active--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__Sender *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Sender, 0, sizeof(struct ns1__Sender), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ConfigProfile(struct soap *soap, struct ns1__ConfigProfile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->config_USCOREid = NULL;
	soap_default_string(soap, &a->config_USCOREname);
	soap_default_string(soap, &a->paper_USCOREtype);
	soap_default_string(soap, &a->paper_USCOREprint_USCOREtype);
	soap_default_string(soap, &a->envelope_USCOREtype);
	soap_default_string(soap, &a->envelope_USCOREtemplate);
	soap_default_string(soap, &a->envelope_USCOREprint_USCOREtype);
	soap_default_string(soap, &a->carrier);
	soap_default_string(soap, &a->dispatch_USCOREtype);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ConfigProfile(struct soap *soap, const struct ns1__ConfigProfile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->config_USCOREid);
	soap_serialize_string(soap, &a->config_USCOREname);
	soap_serialize_string(soap, &a->paper_USCOREtype);
	soap_serialize_string(soap, &a->paper_USCOREprint_USCOREtype);
	soap_serialize_string(soap, &a->envelope_USCOREtype);
	soap_serialize_string(soap, &a->envelope_USCOREtemplate);
	soap_serialize_string(soap, &a->envelope_USCOREprint_USCOREtype);
	soap_serialize_string(soap, &a->carrier);
	soap_serialize_string(soap, &a->dispatch_USCOREtype);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ConfigProfile(struct soap *soap, const struct ns1__ConfigProfile *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__ConfigProfile);
	if (soap_out_ns1__ConfigProfile(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ConfigProfile(struct soap *soap, const char *tag, int id, const struct ns1__ConfigProfile *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ConfigProfile), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "config_id", -1, &a->config_USCOREid, ""))
		return soap->error;
	if (soap_out_string(soap, "config_name", -1, &a->config_USCOREname, ""))
		return soap->error;
	if (soap_out_string(soap, "paper_type", -1, &a->paper_USCOREtype, ""))
		return soap->error;
	if (soap_out_string(soap, "paper_print_type", -1, &a->paper_USCOREprint_USCOREtype, ""))
		return soap->error;
	if (soap_out_string(soap, "envelope_type", -1, &a->envelope_USCOREtype, ""))
		return soap->error;
	if (soap_out_string(soap, "envelope_template", -1, &a->envelope_USCOREtemplate, ""))
		return soap->error;
	if (soap_out_string(soap, "envelope_print_type", -1, &a->envelope_USCOREprint_USCOREtype, ""))
		return soap->error;
	if (soap_out_string(soap, "carrier", -1, &a->carrier, ""))
		return soap->error;
	if (soap_out_string(soap, "dispatch_type", -1, &a->dispatch_USCOREtype, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__ConfigProfile * SOAP_FMAC4 soap_get_ns1__ConfigProfile(struct soap *soap, struct ns1__ConfigProfile *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ConfigProfile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__ConfigProfile * SOAP_FMAC4 soap_in_ns1__ConfigProfile(struct soap *soap, const char *tag, struct ns1__ConfigProfile *a, const char *type)
{
	size_t soap_flag_config_USCOREid = 1;
	size_t soap_flag_config_USCOREname = 1;
	size_t soap_flag_paper_USCOREtype = 1;
	size_t soap_flag_paper_USCOREprint_USCOREtype = 1;
	size_t soap_flag_envelope_USCOREtype = 1;
	size_t soap_flag_envelope_USCOREtemplate = 1;
	size_t soap_flag_envelope_USCOREprint_USCOREtype = 1;
	size_t soap_flag_carrier = 1;
	size_t soap_flag_dispatch_USCOREtype = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__ConfigProfile *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ConfigProfile, sizeof(struct ns1__ConfigProfile), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__ConfigProfile(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_config_USCOREid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "config_id", &a->config_USCOREid, "xsd:int"))
				{	soap_flag_config_USCOREid--;
					continue;
				}
			if (soap_flag_config_USCOREname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "config_name", &a->config_USCOREname, "xsd:string"))
				{	soap_flag_config_USCOREname--;
					continue;
				}
			if (soap_flag_paper_USCOREtype && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "paper_type", &a->paper_USCOREtype, "xsd:string"))
				{	soap_flag_paper_USCOREtype--;
					continue;
				}
			if (soap_flag_paper_USCOREprint_USCOREtype && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "paper_print_type", &a->paper_USCOREprint_USCOREtype, "xsd:string"))
				{	soap_flag_paper_USCOREprint_USCOREtype--;
					continue;
				}
			if (soap_flag_envelope_USCOREtype && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "envelope_type", &a->envelope_USCOREtype, "xsd:string"))
				{	soap_flag_envelope_USCOREtype--;
					continue;
				}
			if (soap_flag_envelope_USCOREtemplate && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "envelope_template", &a->envelope_USCOREtemplate, "xsd:string"))
				{	soap_flag_envelope_USCOREtemplate--;
					continue;
				}
			if (soap_flag_envelope_USCOREprint_USCOREtype && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "envelope_print_type", &a->envelope_USCOREprint_USCOREtype, "xsd:string"))
				{	soap_flag_envelope_USCOREprint_USCOREtype--;
					continue;
				}
			if (soap_flag_carrier && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "carrier", &a->carrier, "xsd:string"))
				{	soap_flag_carrier--;
					continue;
				}
			if (soap_flag_dispatch_USCOREtype && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "dispatch_type", &a->dispatch_USCOREtype, "xsd:string"))
				{	soap_flag_dispatch_USCOREtype--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__ConfigProfile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ConfigProfile, 0, sizeof(struct ns1__ConfigProfile), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__Shipment(struct soap *soap, struct ns1__Shipment *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->id);
	soap_default_string(soap, &a->custom_USCOREid);
	soap_default_string(soap, &a->recipient_USCOREname);
	soap_default_string(soap, &a->recipient_USCOREaddress);
	soap_default_string(soap, &a->recipient_USCOREhome_USCOREnumber);
	soap_default_string(soap, &a->recipient_USCOREflat_USCOREnumber);
	soap_default_string(soap, &a->recipient_USCOREpost_USCOREcode);
	soap_default_string(soap, &a->recipient_USCOREcity);
	soap_default_string(soap, &a->recipient_USCOREcountry);
	soap_default_string(soap, &a->recipient_USCOREfax_USCOREnumber);
	soap_default_string(soap, &a->dispatch_USCOREcarrier);
	soap_default_string(soap, &a->dispatch_USCOREtype);
	a->page_USCOREnumber = NULL;
	a->price = NULL;
	soap_default_string(soap, &a->status);
	soap_default_string(soap, &a->status_USCOREcode);
	soap_default_string(soap, &a->status_USCOREdescription);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__Shipment(struct soap *soap, const struct ns1__Shipment *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->id);
	soap_serialize_string(soap, &a->custom_USCOREid);
	soap_serialize_string(soap, &a->recipient_USCOREname);
	soap_serialize_string(soap, &a->recipient_USCOREaddress);
	soap_serialize_string(soap, &a->recipient_USCOREhome_USCOREnumber);
	soap_serialize_string(soap, &a->recipient_USCOREflat_USCOREnumber);
	soap_serialize_string(soap, &a->recipient_USCOREpost_USCOREcode);
	soap_serialize_string(soap, &a->recipient_USCOREcity);
	soap_serialize_string(soap, &a->recipient_USCOREcountry);
	soap_serialize_string(soap, &a->recipient_USCOREfax_USCOREnumber);
	soap_serialize_string(soap, &a->dispatch_USCOREcarrier);
	soap_serialize_string(soap, &a->dispatch_USCOREtype);
	soap_serialize_PointerToint(soap, &a->page_USCOREnumber);
	soap_serialize_PointerTofloat(soap, &a->price);
	soap_serialize_string(soap, &a->status);
	soap_serialize_string(soap, &a->status_USCOREcode);
	soap_serialize_string(soap, &a->status_USCOREdescription);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__Shipment(struct soap *soap, const struct ns1__Shipment *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__Shipment);
	if (soap_out_ns1__Shipment(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Shipment(struct soap *soap, const char *tag, int id, const struct ns1__Shipment *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Shipment), type))
		return soap->error;
	if (soap_out_string(soap, "id", -1, &a->id, ""))
		return soap->error;
	if (soap_out_string(soap, "custom_id", -1, &a->custom_USCOREid, ""))
		return soap->error;
	if (soap_out_string(soap, "recipient_name", -1, &a->recipient_USCOREname, ""))
		return soap->error;
	if (soap_out_string(soap, "recipient_address", -1, &a->recipient_USCOREaddress, ""))
		return soap->error;
	if (soap_out_string(soap, "recipient_home_number", -1, &a->recipient_USCOREhome_USCOREnumber, ""))
		return soap->error;
	if (soap_out_string(soap, "recipient_flat_number", -1, &a->recipient_USCOREflat_USCOREnumber, ""))
		return soap->error;
	if (soap_out_string(soap, "recipient_post_code", -1, &a->recipient_USCOREpost_USCOREcode, ""))
		return soap->error;
	if (soap_out_string(soap, "recipient_city", -1, &a->recipient_USCOREcity, ""))
		return soap->error;
	if (soap_out_string(soap, "recipient_country", -1, &a->recipient_USCOREcountry, ""))
		return soap->error;
	if (soap_out_string(soap, "recipient_fax_number", -1, &a->recipient_USCOREfax_USCOREnumber, ""))
		return soap->error;
	if (soap_out_string(soap, "dispatch_carrier", -1, &a->dispatch_USCOREcarrier, ""))
		return soap->error;
	if (soap_out_string(soap, "dispatch_type", -1, &a->dispatch_USCOREtype, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "page_number", -1, &a->page_USCOREnumber, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "price", -1, &a->price, ""))
		return soap->error;
	if (soap_out_string(soap, "status", -1, &a->status, ""))
		return soap->error;
	if (soap_out_string(soap, "status_code", -1, &a->status_USCOREcode, ""))
		return soap->error;
	if (soap_out_string(soap, "status_description", -1, &a->status_USCOREdescription, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__Shipment * SOAP_FMAC4 soap_get_ns1__Shipment(struct soap *soap, struct ns1__Shipment *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Shipment(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__Shipment * SOAP_FMAC4 soap_in_ns1__Shipment(struct soap *soap, const char *tag, struct ns1__Shipment *a, const char *type)
{
	size_t soap_flag_id = 1;
	size_t soap_flag_custom_USCOREid = 1;
	size_t soap_flag_recipient_USCOREname = 1;
	size_t soap_flag_recipient_USCOREaddress = 1;
	size_t soap_flag_recipient_USCOREhome_USCOREnumber = 1;
	size_t soap_flag_recipient_USCOREflat_USCOREnumber = 1;
	size_t soap_flag_recipient_USCOREpost_USCOREcode = 1;
	size_t soap_flag_recipient_USCOREcity = 1;
	size_t soap_flag_recipient_USCOREcountry = 1;
	size_t soap_flag_recipient_USCOREfax_USCOREnumber = 1;
	size_t soap_flag_dispatch_USCOREcarrier = 1;
	size_t soap_flag_dispatch_USCOREtype = 1;
	size_t soap_flag_page_USCOREnumber = 1;
	size_t soap_flag_price = 1;
	size_t soap_flag_status = 1;
	size_t soap_flag_status_USCOREcode = 1;
	size_t soap_flag_status_USCOREdescription = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__Shipment *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Shipment, sizeof(struct ns1__Shipment), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__Shipment(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "id", &a->id, "xsd:string"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_custom_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "custom_id", &a->custom_USCOREid, "xsd:string"))
				{	soap_flag_custom_USCOREid--;
					continue;
				}
			if (soap_flag_recipient_USCOREname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "recipient_name", &a->recipient_USCOREname, "xsd:string"))
				{	soap_flag_recipient_USCOREname--;
					continue;
				}
			if (soap_flag_recipient_USCOREaddress && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "recipient_address", &a->recipient_USCOREaddress, "xsd:string"))
				{	soap_flag_recipient_USCOREaddress--;
					continue;
				}
			if (soap_flag_recipient_USCOREhome_USCOREnumber && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "recipient_home_number", &a->recipient_USCOREhome_USCOREnumber, "xsd:string"))
				{	soap_flag_recipient_USCOREhome_USCOREnumber--;
					continue;
				}
			if (soap_flag_recipient_USCOREflat_USCOREnumber && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "recipient_flat_number", &a->recipient_USCOREflat_USCOREnumber, "xsd:string"))
				{	soap_flag_recipient_USCOREflat_USCOREnumber--;
					continue;
				}
			if (soap_flag_recipient_USCOREpost_USCOREcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "recipient_post_code", &a->recipient_USCOREpost_USCOREcode, "xsd:string"))
				{	soap_flag_recipient_USCOREpost_USCOREcode--;
					continue;
				}
			if (soap_flag_recipient_USCOREcity && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "recipient_city", &a->recipient_USCOREcity, "xsd:string"))
				{	soap_flag_recipient_USCOREcity--;
					continue;
				}
			if (soap_flag_recipient_USCOREcountry && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "recipient_country", &a->recipient_USCOREcountry, "xsd:string"))
				{	soap_flag_recipient_USCOREcountry--;
					continue;
				}
			if (soap_flag_recipient_USCOREfax_USCOREnumber && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "recipient_fax_number", &a->recipient_USCOREfax_USCOREnumber, "xsd:string"))
				{	soap_flag_recipient_USCOREfax_USCOREnumber--;
					continue;
				}
			if (soap_flag_dispatch_USCOREcarrier && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "dispatch_carrier", &a->dispatch_USCOREcarrier, "xsd:string"))
				{	soap_flag_dispatch_USCOREcarrier--;
					continue;
				}
			if (soap_flag_dispatch_USCOREtype && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "dispatch_type", &a->dispatch_USCOREtype, "xsd:string"))
				{	soap_flag_dispatch_USCOREtype--;
					continue;
				}
			if (soap_flag_page_USCOREnumber && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "page_number", &a->page_USCOREnumber, "xsd:int"))
				{	soap_flag_page_USCOREnumber--;
					continue;
				}
			if (soap_flag_price && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "price", &a->price, "xsd:float"))
				{	soap_flag_price--;
					continue;
				}
			if (soap_flag_status && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "status", &a->status, "xsd:string"))
				{	soap_flag_status--;
					continue;
				}
			if (soap_flag_status_USCOREcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "status_code", &a->status_USCOREcode, "xsd:string"))
				{	soap_flag_status_USCOREcode--;
					continue;
				}
			if (soap_flag_status_USCOREdescription && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "status_description", &a->status_USCOREdescription, "xsd:string"))
				{	soap_flag_status_USCOREdescription--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__Shipment *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Shipment, 0, sizeof(struct ns1__Shipment), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__Option(struct soap *soap, struct ns1__Option *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->name);
	soap_default_string(soap, &a->value);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__Option(struct soap *soap, const struct ns1__Option *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->name);
	soap_serialize_string(soap, &a->value);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__Option(struct soap *soap, const struct ns1__Option *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__Option);
	if (soap_out_ns1__Option(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Option(struct soap *soap, const char *tag, int id, const struct ns1__Option *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Option), type))
		return soap->error;
	if (soap_out_string(soap, "name", -1, &a->name, ""))
		return soap->error;
	if (soap_out_string(soap, "value", -1, &a->value, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__Option * SOAP_FMAC4 soap_get_ns1__Option(struct soap *soap, struct ns1__Option *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Option(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__Option * SOAP_FMAC4 soap_in_ns1__Option(struct soap *soap, const char *tag, struct ns1__Option *a, const char *type)
{
	size_t soap_flag_name = 1;
	size_t soap_flag_value = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__Option *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Option, sizeof(struct ns1__Option), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__Option(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &a->name, "xsd:string"))
				{	soap_flag_name--;
					continue;
				}
			if (soap_flag_value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "value", &a->value, "xsd:string"))
				{	soap_flag_value--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__Option *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Option, 0, sizeof(struct ns1__Option), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_name > 0 || soap_flag_value > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__Recipient(struct soap *soap, struct ns1__Recipient *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->source);
	a->id = NULL;
	soap_default_string(soap, &a->recipient_USCOREname);
	soap_default_string(soap, &a->recipient_USCOREaddress_USCOREprefix);
	soap_default_string(soap, &a->recipient_USCOREaddress);
	soap_default_string(soap, &a->recipient_USCOREhome_USCOREnumber);
	soap_default_string(soap, &a->recipient_USCOREflat_USCOREnumber);
	soap_default_string(soap, &a->recipient_USCOREpost_USCOREcode);
	soap_default_string(soap, &a->recipient_USCOREcity);
	soap_default_string(soap, &a->recipient_USCOREcountry);
	soap_default_string(soap, &a->recipient_USCOREfax_USCOREnumber);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__Recipient(struct soap *soap, const struct ns1__Recipient *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->source);
	soap_serialize_PointerToint(soap, &a->id);
	soap_serialize_string(soap, &a->recipient_USCOREname);
	soap_serialize_string(soap, &a->recipient_USCOREaddress_USCOREprefix);
	soap_serialize_string(soap, &a->recipient_USCOREaddress);
	soap_serialize_string(soap, &a->recipient_USCOREhome_USCOREnumber);
	soap_serialize_string(soap, &a->recipient_USCOREflat_USCOREnumber);
	soap_serialize_string(soap, &a->recipient_USCOREpost_USCOREcode);
	soap_serialize_string(soap, &a->recipient_USCOREcity);
	soap_serialize_string(soap, &a->recipient_USCOREcountry);
	soap_serialize_string(soap, &a->recipient_USCOREfax_USCOREnumber);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__Recipient(struct soap *soap, const struct ns1__Recipient *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__Recipient);
	if (soap_out_ns1__Recipient(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Recipient(struct soap *soap, const char *tag, int id, const struct ns1__Recipient *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Recipient), type))
		return soap->error;
	if (soap_out_string(soap, "source", -1, &a->source, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "id", -1, &a->id, ""))
		return soap->error;
	if (soap_out_string(soap, "recipient_name", -1, &a->recipient_USCOREname, ""))
		return soap->error;
	if (soap_out_string(soap, "recipient_address_prefix", -1, &a->recipient_USCOREaddress_USCOREprefix, ""))
		return soap->error;
	if (soap_out_string(soap, "recipient_address", -1, &a->recipient_USCOREaddress, ""))
		return soap->error;
	if (soap_out_string(soap, "recipient_home_number", -1, &a->recipient_USCOREhome_USCOREnumber, ""))
		return soap->error;
	if (soap_out_string(soap, "recipient_flat_number", -1, &a->recipient_USCOREflat_USCOREnumber, ""))
		return soap->error;
	if (soap_out_string(soap, "recipient_post_code", -1, &a->recipient_USCOREpost_USCOREcode, ""))
		return soap->error;
	if (soap_out_string(soap, "recipient_city", -1, &a->recipient_USCOREcity, ""))
		return soap->error;
	if (soap_out_string(soap, "recipient_country", -1, &a->recipient_USCOREcountry, ""))
		return soap->error;
	if (soap_out_string(soap, "recipient_fax_number", -1, &a->recipient_USCOREfax_USCOREnumber, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__Recipient * SOAP_FMAC4 soap_get_ns1__Recipient(struct soap *soap, struct ns1__Recipient *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Recipient(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__Recipient * SOAP_FMAC4 soap_in_ns1__Recipient(struct soap *soap, const char *tag, struct ns1__Recipient *a, const char *type)
{
	size_t soap_flag_source = 1;
	size_t soap_flag_id = 1;
	size_t soap_flag_recipient_USCOREname = 1;
	size_t soap_flag_recipient_USCOREaddress_USCOREprefix = 1;
	size_t soap_flag_recipient_USCOREaddress = 1;
	size_t soap_flag_recipient_USCOREhome_USCOREnumber = 1;
	size_t soap_flag_recipient_USCOREflat_USCOREnumber = 1;
	size_t soap_flag_recipient_USCOREpost_USCOREcode = 1;
	size_t soap_flag_recipient_USCOREcity = 1;
	size_t soap_flag_recipient_USCOREcountry = 1;
	size_t soap_flag_recipient_USCOREfax_USCOREnumber = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__Recipient *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Recipient, sizeof(struct ns1__Recipient), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__Recipient(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_source && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "source", &a->source, "xsd:string"))
				{	soap_flag_source--;
					continue;
				}
			if (soap_flag_id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "id", &a->id, "xsd:int"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_recipient_USCOREname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "recipient_name", &a->recipient_USCOREname, "xsd:string"))
				{	soap_flag_recipient_USCOREname--;
					continue;
				}
			if (soap_flag_recipient_USCOREaddress_USCOREprefix && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "recipient_address_prefix", &a->recipient_USCOREaddress_USCOREprefix, "xsd:string"))
				{	soap_flag_recipient_USCOREaddress_USCOREprefix--;
					continue;
				}
			if (soap_flag_recipient_USCOREaddress && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "recipient_address", &a->recipient_USCOREaddress, "xsd:string"))
				{	soap_flag_recipient_USCOREaddress--;
					continue;
				}
			if (soap_flag_recipient_USCOREhome_USCOREnumber && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "recipient_home_number", &a->recipient_USCOREhome_USCOREnumber, "xsd:string"))
				{	soap_flag_recipient_USCOREhome_USCOREnumber--;
					continue;
				}
			if (soap_flag_recipient_USCOREflat_USCOREnumber && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "recipient_flat_number", &a->recipient_USCOREflat_USCOREnumber, "xsd:string"))
				{	soap_flag_recipient_USCOREflat_USCOREnumber--;
					continue;
				}
			if (soap_flag_recipient_USCOREpost_USCOREcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "recipient_post_code", &a->recipient_USCOREpost_USCOREcode, "xsd:string"))
				{	soap_flag_recipient_USCOREpost_USCOREcode--;
					continue;
				}
			if (soap_flag_recipient_USCOREcity && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "recipient_city", &a->recipient_USCOREcity, "xsd:string"))
				{	soap_flag_recipient_USCOREcity--;
					continue;
				}
			if (soap_flag_recipient_USCOREcountry && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "recipient_country", &a->recipient_USCOREcountry, "xsd:string"))
				{	soap_flag_recipient_USCOREcountry--;
					continue;
				}
			if (soap_flag_recipient_USCOREfax_USCOREnumber && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "recipient_fax_number", &a->recipient_USCOREfax_USCOREnumber, "xsd:string"))
				{	soap_flag_recipient_USCOREfax_USCOREnumber--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__Recipient *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Recipient, 0, sizeof(struct ns1__Recipient), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__DocumentFile(struct soap *soap, struct ns1__DocumentFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->file_USCOREstream);
	soap_default_string(soap, &a->file_USCOREname);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__DocumentFile(struct soap *soap, const struct ns1__DocumentFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->file_USCOREstream);
	soap_serialize_string(soap, &a->file_USCOREname);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__DocumentFile(struct soap *soap, const struct ns1__DocumentFile *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__DocumentFile);
	if (soap_out_ns1__DocumentFile(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DocumentFile(struct soap *soap, const char *tag, int id, const struct ns1__DocumentFile *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DocumentFile), type))
		return soap->error;
	if (soap_out_string(soap, "file_stream", -1, &a->file_USCOREstream, ""))
		return soap->error;
	if (soap_out_string(soap, "file_name", -1, &a->file_USCOREname, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__DocumentFile * SOAP_FMAC4 soap_get_ns1__DocumentFile(struct soap *soap, struct ns1__DocumentFile *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DocumentFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__DocumentFile * SOAP_FMAC4 soap_in_ns1__DocumentFile(struct soap *soap, const char *tag, struct ns1__DocumentFile *a, const char *type)
{
	size_t soap_flag_file_USCOREstream = 1;
	size_t soap_flag_file_USCOREname = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__DocumentFile *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DocumentFile, sizeof(struct ns1__DocumentFile), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__DocumentFile(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_file_USCOREstream && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "file_stream", &a->file_USCOREstream, "xsd:string"))
				{	soap_flag_file_USCOREstream--;
					continue;
				}
			if (soap_flag_file_USCOREname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "file_name", &a->file_USCOREname, "xsd:string"))
				{	soap_flag_file_USCOREname--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__DocumentFile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DocumentFile, 0, sizeof(struct ns1__DocumentFile), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_file_USCOREstream > 0 || soap_flag_file_USCOREname > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__removeSenderResponse(struct soap *soap, struct ns2__removeSenderResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__removeSenderResponse))
		soap_serialize_ns2__removeSenderResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__removeSenderResponse(struct soap *soap, struct ns2__removeSenderResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__removeSenderResponse);
	if (soap_out_PointerTons2__removeSenderResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__removeSenderResponse(struct soap *soap, const char *tag, int id, struct ns2__removeSenderResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__removeSenderResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__removeSenderResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__removeSenderResponse ** SOAP_FMAC4 soap_get_PointerTons2__removeSenderResponse(struct soap *soap, struct ns2__removeSenderResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__removeSenderResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns2__removeSenderResponse ** SOAP_FMAC4 soap_in_PointerTons2__removeSenderResponse(struct soap *soap, const char *tag, struct ns2__removeSenderResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__removeSenderResponse **)soap_malloc(soap, sizeof(struct ns2__removeSenderResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__removeSenderResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__removeSenderResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__removeSenderResponse, sizeof(struct ns2__removeSenderResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__RemoveSenderReturnObject(struct soap *soap, struct ns1__RemoveSenderReturnObject *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__RemoveSenderReturnObject))
		soap_serialize_ns1__RemoveSenderReturnObject(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__RemoveSenderReturnObject(struct soap *soap, struct ns1__RemoveSenderReturnObject *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__RemoveSenderReturnObject);
	if (soap_out_PointerTons1__RemoveSenderReturnObject(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__RemoveSenderReturnObject(struct soap *soap, const char *tag, int id, struct ns1__RemoveSenderReturnObject *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__RemoveSenderReturnObject);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__RemoveSenderReturnObject(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__RemoveSenderReturnObject ** SOAP_FMAC4 soap_get_PointerTons1__RemoveSenderReturnObject(struct soap *soap, struct ns1__RemoveSenderReturnObject **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__RemoveSenderReturnObject(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__RemoveSenderReturnObject ** SOAP_FMAC4 soap_in_PointerTons1__RemoveSenderReturnObject(struct soap *soap, const char *tag, struct ns1__RemoveSenderReturnObject **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__RemoveSenderReturnObject **)soap_malloc(soap, sizeof(struct ns1__RemoveSenderReturnObject *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__RemoveSenderReturnObject(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__RemoveSenderReturnObject **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__RemoveSenderReturnObject, sizeof(struct ns1__RemoveSenderReturnObject), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__verifySenderResponse(struct soap *soap, struct ns2__verifySenderResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__verifySenderResponse))
		soap_serialize_ns2__verifySenderResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__verifySenderResponse(struct soap *soap, struct ns2__verifySenderResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__verifySenderResponse);
	if (soap_out_PointerTons2__verifySenderResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__verifySenderResponse(struct soap *soap, const char *tag, int id, struct ns2__verifySenderResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__verifySenderResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__verifySenderResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__verifySenderResponse ** SOAP_FMAC4 soap_get_PointerTons2__verifySenderResponse(struct soap *soap, struct ns2__verifySenderResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__verifySenderResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns2__verifySenderResponse ** SOAP_FMAC4 soap_in_PointerTons2__verifySenderResponse(struct soap *soap, const char *tag, struct ns2__verifySenderResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__verifySenderResponse **)soap_malloc(soap, sizeof(struct ns2__verifySenderResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__verifySenderResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__verifySenderResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__verifySenderResponse, sizeof(struct ns2__verifySenderResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__VerifySenderReturnObject(struct soap *soap, struct ns1__VerifySenderReturnObject *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__VerifySenderReturnObject))
		soap_serialize_ns1__VerifySenderReturnObject(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__VerifySenderReturnObject(struct soap *soap, struct ns1__VerifySenderReturnObject *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__VerifySenderReturnObject);
	if (soap_out_PointerTons1__VerifySenderReturnObject(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__VerifySenderReturnObject(struct soap *soap, const char *tag, int id, struct ns1__VerifySenderReturnObject *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__VerifySenderReturnObject);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__VerifySenderReturnObject(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__VerifySenderReturnObject ** SOAP_FMAC4 soap_get_PointerTons1__VerifySenderReturnObject(struct soap *soap, struct ns1__VerifySenderReturnObject **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__VerifySenderReturnObject(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__VerifySenderReturnObject ** SOAP_FMAC4 soap_in_PointerTons1__VerifySenderReturnObject(struct soap *soap, const char *tag, struct ns1__VerifySenderReturnObject **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__VerifySenderReturnObject **)soap_malloc(soap, sizeof(struct ns1__VerifySenderReturnObject *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__VerifySenderReturnObject(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__VerifySenderReturnObject **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__VerifySenderReturnObject, sizeof(struct ns1__VerifySenderReturnObject), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__addSenderResponse(struct soap *soap, struct ns2__addSenderResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__addSenderResponse))
		soap_serialize_ns2__addSenderResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__addSenderResponse(struct soap *soap, struct ns2__addSenderResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__addSenderResponse);
	if (soap_out_PointerTons2__addSenderResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__addSenderResponse(struct soap *soap, const char *tag, int id, struct ns2__addSenderResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__addSenderResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__addSenderResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__addSenderResponse ** SOAP_FMAC4 soap_get_PointerTons2__addSenderResponse(struct soap *soap, struct ns2__addSenderResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__addSenderResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns2__addSenderResponse ** SOAP_FMAC4 soap_in_PointerTons2__addSenderResponse(struct soap *soap, const char *tag, struct ns2__addSenderResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__addSenderResponse **)soap_malloc(soap, sizeof(struct ns2__addSenderResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__addSenderResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__addSenderResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__addSenderResponse, sizeof(struct ns2__addSenderResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SenderData(struct soap *soap, struct ns1__SenderData *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SenderData))
		soap_serialize_ns1__SenderData(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SenderData(struct soap *soap, struct ns1__SenderData *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__SenderData);
	if (soap_out_PointerTons1__SenderData(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SenderData(struct soap *soap, const char *tag, int id, struct ns1__SenderData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SenderData);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__SenderData(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__SenderData ** SOAP_FMAC4 soap_get_PointerTons1__SenderData(struct soap *soap, struct ns1__SenderData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SenderData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__SenderData ** SOAP_FMAC4 soap_in_PointerTons1__SenderData(struct soap *soap, const char *tag, struct ns1__SenderData **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__SenderData **)soap_malloc(soap, sizeof(struct ns1__SenderData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__SenderData(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__SenderData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SenderData, sizeof(struct ns1__SenderData), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__AddSenderReturnObject(struct soap *soap, struct ns1__AddSenderReturnObject *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__AddSenderReturnObject))
		soap_serialize_ns1__AddSenderReturnObject(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__AddSenderReturnObject(struct soap *soap, struct ns1__AddSenderReturnObject *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__AddSenderReturnObject);
	if (soap_out_PointerTons1__AddSenderReturnObject(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__AddSenderReturnObject(struct soap *soap, const char *tag, int id, struct ns1__AddSenderReturnObject *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__AddSenderReturnObject);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__AddSenderReturnObject(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__AddSenderReturnObject ** SOAP_FMAC4 soap_get_PointerTons1__AddSenderReturnObject(struct soap *soap, struct ns1__AddSenderReturnObject **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__AddSenderReturnObject(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__AddSenderReturnObject ** SOAP_FMAC4 soap_in_PointerTons1__AddSenderReturnObject(struct soap *soap, const char *tag, struct ns1__AddSenderReturnObject **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__AddSenderReturnObject **)soap_malloc(soap, sizeof(struct ns1__AddSenderReturnObject *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__AddSenderReturnObject(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__AddSenderReturnObject **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__AddSenderReturnObject, sizeof(struct ns1__AddSenderReturnObject), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__getPriceResponse(struct soap *soap, struct ns2__getPriceResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__getPriceResponse))
		soap_serialize_ns2__getPriceResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__getPriceResponse(struct soap *soap, struct ns2__getPriceResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__getPriceResponse);
	if (soap_out_PointerTons2__getPriceResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__getPriceResponse(struct soap *soap, const char *tag, int id, struct ns2__getPriceResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__getPriceResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__getPriceResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__getPriceResponse ** SOAP_FMAC4 soap_get_PointerTons2__getPriceResponse(struct soap *soap, struct ns2__getPriceResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__getPriceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns2__getPriceResponse ** SOAP_FMAC4 soap_in_PointerTons2__getPriceResponse(struct soap *soap, const char *tag, struct ns2__getPriceResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__getPriceResponse **)soap_malloc(soap, sizeof(struct ns2__getPriceResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__getPriceResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__getPriceResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__getPriceResponse, sizeof(struct ns2__getPriceResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__PriceReturnObject(struct soap *soap, struct ns1__PriceReturnObject *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__PriceReturnObject))
		soap_serialize_ns1__PriceReturnObject(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__PriceReturnObject(struct soap *soap, struct ns1__PriceReturnObject *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__PriceReturnObject);
	if (soap_out_PointerTons1__PriceReturnObject(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__PriceReturnObject(struct soap *soap, const char *tag, int id, struct ns1__PriceReturnObject *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__PriceReturnObject);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__PriceReturnObject(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__PriceReturnObject ** SOAP_FMAC4 soap_get_PointerTons1__PriceReturnObject(struct soap *soap, struct ns1__PriceReturnObject **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__PriceReturnObject(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__PriceReturnObject ** SOAP_FMAC4 soap_in_PointerTons1__PriceReturnObject(struct soap *soap, const char *tag, struct ns1__PriceReturnObject **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__PriceReturnObject **)soap_malloc(soap, sizeof(struct ns1__PriceReturnObject *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__PriceReturnObject(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__PriceReturnObject **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__PriceReturnObject, sizeof(struct ns1__PriceReturnObject), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__getCertificateResponse(struct soap *soap, struct ns2__getCertificateResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__getCertificateResponse))
		soap_serialize_ns2__getCertificateResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__getCertificateResponse(struct soap *soap, struct ns2__getCertificateResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__getCertificateResponse);
	if (soap_out_PointerTons2__getCertificateResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__getCertificateResponse(struct soap *soap, const char *tag, int id, struct ns2__getCertificateResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__getCertificateResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__getCertificateResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__getCertificateResponse ** SOAP_FMAC4 soap_get_PointerTons2__getCertificateResponse(struct soap *soap, struct ns2__getCertificateResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__getCertificateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns2__getCertificateResponse ** SOAP_FMAC4 soap_in_PointerTons2__getCertificateResponse(struct soap *soap, const char *tag, struct ns2__getCertificateResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__getCertificateResponse **)soap_malloc(soap, sizeof(struct ns2__getCertificateResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__getCertificateResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__getCertificateResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__getCertificateResponse, sizeof(struct ns2__getCertificateResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CertificateReturnObject(struct soap *soap, struct ns1__CertificateReturnObject *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CertificateReturnObject))
		soap_serialize_ns1__CertificateReturnObject(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CertificateReturnObject(struct soap *soap, struct ns1__CertificateReturnObject *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CertificateReturnObject);
	if (soap_out_PointerTons1__CertificateReturnObject(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CertificateReturnObject(struct soap *soap, const char *tag, int id, struct ns1__CertificateReturnObject *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CertificateReturnObject);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__CertificateReturnObject(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__CertificateReturnObject ** SOAP_FMAC4 soap_get_PointerTons1__CertificateReturnObject(struct soap *soap, struct ns1__CertificateReturnObject **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CertificateReturnObject(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__CertificateReturnObject ** SOAP_FMAC4 soap_in_PointerTons1__CertificateReturnObject(struct soap *soap, const char *tag, struct ns1__CertificateReturnObject **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__CertificateReturnObject **)soap_malloc(soap, sizeof(struct ns1__CertificateReturnObject *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__CertificateReturnObject(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__CertificateReturnObject **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CertificateReturnObject, sizeof(struct ns1__CertificateReturnObject), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__getSendersResponse(struct soap *soap, struct ns2__getSendersResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__getSendersResponse))
		soap_serialize_ns2__getSendersResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__getSendersResponse(struct soap *soap, struct ns2__getSendersResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__getSendersResponse);
	if (soap_out_PointerTons2__getSendersResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__getSendersResponse(struct soap *soap, const char *tag, int id, struct ns2__getSendersResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__getSendersResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__getSendersResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__getSendersResponse ** SOAP_FMAC4 soap_get_PointerTons2__getSendersResponse(struct soap *soap, struct ns2__getSendersResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__getSendersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns2__getSendersResponse ** SOAP_FMAC4 soap_in_PointerTons2__getSendersResponse(struct soap *soap, const char *tag, struct ns2__getSendersResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__getSendersResponse **)soap_malloc(soap, sizeof(struct ns2__getSendersResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__getSendersResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__getSendersResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__getSendersResponse, sizeof(struct ns2__getSendersResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SendersReturnObject(struct soap *soap, struct ns1__SendersReturnObject *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SendersReturnObject))
		soap_serialize_ns1__SendersReturnObject(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SendersReturnObject(struct soap *soap, struct ns1__SendersReturnObject *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__SendersReturnObject);
	if (soap_out_PointerTons1__SendersReturnObject(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SendersReturnObject(struct soap *soap, const char *tag, int id, struct ns1__SendersReturnObject *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SendersReturnObject);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__SendersReturnObject(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__SendersReturnObject ** SOAP_FMAC4 soap_get_PointerTons1__SendersReturnObject(struct soap *soap, struct ns1__SendersReturnObject **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SendersReturnObject(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__SendersReturnObject ** SOAP_FMAC4 soap_in_PointerTons1__SendersReturnObject(struct soap *soap, const char *tag, struct ns1__SendersReturnObject **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__SendersReturnObject **)soap_malloc(soap, sizeof(struct ns1__SendersReturnObject *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__SendersReturnObject(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__SendersReturnObject **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SendersReturnObject, sizeof(struct ns1__SendersReturnObject), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__getConfigProfilesResponse(struct soap *soap, struct ns2__getConfigProfilesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__getConfigProfilesResponse))
		soap_serialize_ns2__getConfigProfilesResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__getConfigProfilesResponse(struct soap *soap, struct ns2__getConfigProfilesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__getConfigProfilesResponse);
	if (soap_out_PointerTons2__getConfigProfilesResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__getConfigProfilesResponse(struct soap *soap, const char *tag, int id, struct ns2__getConfigProfilesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__getConfigProfilesResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__getConfigProfilesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__getConfigProfilesResponse ** SOAP_FMAC4 soap_get_PointerTons2__getConfigProfilesResponse(struct soap *soap, struct ns2__getConfigProfilesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__getConfigProfilesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns2__getConfigProfilesResponse ** SOAP_FMAC4 soap_in_PointerTons2__getConfigProfilesResponse(struct soap *soap, const char *tag, struct ns2__getConfigProfilesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__getConfigProfilesResponse **)soap_malloc(soap, sizeof(struct ns2__getConfigProfilesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__getConfigProfilesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__getConfigProfilesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__getConfigProfilesResponse, sizeof(struct ns2__getConfigProfilesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ConfigProfilesReturnObject(struct soap *soap, struct ns1__ConfigProfilesReturnObject *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ConfigProfilesReturnObject))
		soap_serialize_ns1__ConfigProfilesReturnObject(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ConfigProfilesReturnObject(struct soap *soap, struct ns1__ConfigProfilesReturnObject *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ConfigProfilesReturnObject);
	if (soap_out_PointerTons1__ConfigProfilesReturnObject(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ConfigProfilesReturnObject(struct soap *soap, const char *tag, int id, struct ns1__ConfigProfilesReturnObject *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ConfigProfilesReturnObject);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__ConfigProfilesReturnObject(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__ConfigProfilesReturnObject ** SOAP_FMAC4 soap_get_PointerTons1__ConfigProfilesReturnObject(struct soap *soap, struct ns1__ConfigProfilesReturnObject **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ConfigProfilesReturnObject(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__ConfigProfilesReturnObject ** SOAP_FMAC4 soap_in_PointerTons1__ConfigProfilesReturnObject(struct soap *soap, const char *tag, struct ns1__ConfigProfilesReturnObject **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__ConfigProfilesReturnObject **)soap_malloc(soap, sizeof(struct ns1__ConfigProfilesReturnObject *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__ConfigProfilesReturnObject(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__ConfigProfilesReturnObject **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ConfigProfilesReturnObject, sizeof(struct ns1__ConfigProfilesReturnObject), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__getBalanceResponse(struct soap *soap, struct ns2__getBalanceResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__getBalanceResponse))
		soap_serialize_ns2__getBalanceResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__getBalanceResponse(struct soap *soap, struct ns2__getBalanceResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__getBalanceResponse);
	if (soap_out_PointerTons2__getBalanceResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__getBalanceResponse(struct soap *soap, const char *tag, int id, struct ns2__getBalanceResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__getBalanceResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__getBalanceResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__getBalanceResponse ** SOAP_FMAC4 soap_get_PointerTons2__getBalanceResponse(struct soap *soap, struct ns2__getBalanceResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__getBalanceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns2__getBalanceResponse ** SOAP_FMAC4 soap_in_PointerTons2__getBalanceResponse(struct soap *soap, const char *tag, struct ns2__getBalanceResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__getBalanceResponse **)soap_malloc(soap, sizeof(struct ns2__getBalanceResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__getBalanceResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__getBalanceResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__getBalanceResponse, sizeof(struct ns2__getBalanceResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__BalanceReturnObject(struct soap *soap, struct ns1__BalanceReturnObject *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__BalanceReturnObject))
		soap_serialize_ns1__BalanceReturnObject(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__BalanceReturnObject(struct soap *soap, struct ns1__BalanceReturnObject *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__BalanceReturnObject);
	if (soap_out_PointerTons1__BalanceReturnObject(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__BalanceReturnObject(struct soap *soap, const char *tag, int id, struct ns1__BalanceReturnObject *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__BalanceReturnObject);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__BalanceReturnObject(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__BalanceReturnObject ** SOAP_FMAC4 soap_get_PointerTons1__BalanceReturnObject(struct soap *soap, struct ns1__BalanceReturnObject **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__BalanceReturnObject(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__BalanceReturnObject ** SOAP_FMAC4 soap_in_PointerTons1__BalanceReturnObject(struct soap *soap, const char *tag, struct ns1__BalanceReturnObject **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__BalanceReturnObject **)soap_malloc(soap, sizeof(struct ns1__BalanceReturnObject *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__BalanceReturnObject(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__BalanceReturnObject **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__BalanceReturnObject, sizeof(struct ns1__BalanceReturnObject), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__getDispatchStatusResponse(struct soap *soap, struct ns2__getDispatchStatusResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__getDispatchStatusResponse))
		soap_serialize_ns2__getDispatchStatusResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__getDispatchStatusResponse(struct soap *soap, struct ns2__getDispatchStatusResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__getDispatchStatusResponse);
	if (soap_out_PointerTons2__getDispatchStatusResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__getDispatchStatusResponse(struct soap *soap, const char *tag, int id, struct ns2__getDispatchStatusResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__getDispatchStatusResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__getDispatchStatusResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__getDispatchStatusResponse ** SOAP_FMAC4 soap_get_PointerTons2__getDispatchStatusResponse(struct soap *soap, struct ns2__getDispatchStatusResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__getDispatchStatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns2__getDispatchStatusResponse ** SOAP_FMAC4 soap_in_PointerTons2__getDispatchStatusResponse(struct soap *soap, const char *tag, struct ns2__getDispatchStatusResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__getDispatchStatusResponse **)soap_malloc(soap, sizeof(struct ns2__getDispatchStatusResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__getDispatchStatusResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__getDispatchStatusResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__getDispatchStatusResponse, sizeof(struct ns2__getDispatchStatusResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfDispatchIds(struct soap *soap, struct ArrayOfDispatchIds *const*a)
{
	if (*a)
		soap_serialize_ArrayOfDispatchIds(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfDispatchIds(struct soap *soap, struct ArrayOfDispatchIds *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfDispatchIds);
	if (soap_out_PointerToArrayOfDispatchIds(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfDispatchIds(struct soap *soap, const char *tag, int id, struct ArrayOfDispatchIds *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOfDispatchIds);
	if (id < 0)
		return soap->error;
	return soap_out_ArrayOfDispatchIds(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ArrayOfDispatchIds ** SOAP_FMAC4 soap_get_PointerToArrayOfDispatchIds(struct soap *soap, struct ArrayOfDispatchIds **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfDispatchIds(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ArrayOfDispatchIds ** SOAP_FMAC4 soap_in_PointerToArrayOfDispatchIds(struct soap *soap, const char *tag, struct ArrayOfDispatchIds **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ArrayOfDispatchIds **)soap_malloc(soap, sizeof(struct ArrayOfDispatchIds *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ArrayOfDispatchIds(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ArrayOfDispatchIds **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfDispatchIds, sizeof(struct ArrayOfDispatchIds), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__dispatchResponse(struct soap *soap, struct ns2__dispatchResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__dispatchResponse))
		soap_serialize_ns2__dispatchResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__dispatchResponse(struct soap *soap, struct ns2__dispatchResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__dispatchResponse);
	if (soap_out_PointerTons2__dispatchResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__dispatchResponse(struct soap *soap, const char *tag, int id, struct ns2__dispatchResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__dispatchResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__dispatchResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__dispatchResponse ** SOAP_FMAC4 soap_get_PointerTons2__dispatchResponse(struct soap *soap, struct ns2__dispatchResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__dispatchResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns2__dispatchResponse ** SOAP_FMAC4 soap_in_PointerTons2__dispatchResponse(struct soap *soap, const char *tag, struct ns2__dispatchResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__dispatchResponse **)soap_malloc(soap, sizeof(struct ns2__dispatchResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__dispatchResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__dispatchResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__dispatchResponse, sizeof(struct ns2__dispatchResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfOptions(struct soap *soap, struct ArrayOfOptions *const*a)
{
	if (*a)
		soap_serialize_ArrayOfOptions(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfOptions(struct soap *soap, struct ArrayOfOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfOptions);
	if (soap_out_PointerToArrayOfOptions(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfOptions(struct soap *soap, const char *tag, int id, struct ArrayOfOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOfOptions);
	if (id < 0)
		return soap->error;
	return soap_out_ArrayOfOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ArrayOfOptions ** SOAP_FMAC4 soap_get_PointerToArrayOfOptions(struct soap *soap, struct ArrayOfOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ArrayOfOptions ** SOAP_FMAC4 soap_in_PointerToArrayOfOptions(struct soap *soap, const char *tag, struct ArrayOfOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ArrayOfOptions **)soap_malloc(soap, sizeof(struct ArrayOfOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ArrayOfOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ArrayOfOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfOptions, sizeof(struct ArrayOfOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfRecipients(struct soap *soap, struct ArrayOfRecipients *const*a)
{
	if (*a)
		soap_serialize_ArrayOfRecipients(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfRecipients(struct soap *soap, struct ArrayOfRecipients *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfRecipients);
	if (soap_out_PointerToArrayOfRecipients(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfRecipients(struct soap *soap, const char *tag, int id, struct ArrayOfRecipients *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOfRecipients);
	if (id < 0)
		return soap->error;
	return soap_out_ArrayOfRecipients(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ArrayOfRecipients ** SOAP_FMAC4 soap_get_PointerToArrayOfRecipients(struct soap *soap, struct ArrayOfRecipients **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfRecipients(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ArrayOfRecipients ** SOAP_FMAC4 soap_in_PointerToArrayOfRecipients(struct soap *soap, const char *tag, struct ArrayOfRecipients **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ArrayOfRecipients **)soap_malloc(soap, sizeof(struct ArrayOfRecipients *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ArrayOfRecipients(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ArrayOfRecipients **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfRecipients, sizeof(struct ArrayOfRecipients), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfDocumentFiles(struct soap *soap, struct ArrayOfDocumentFiles *const*a)
{
	if (*a)
		soap_serialize_ArrayOfDocumentFiles(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfDocumentFiles(struct soap *soap, struct ArrayOfDocumentFiles *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfDocumentFiles);
	if (soap_out_PointerToArrayOfDocumentFiles(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfDocumentFiles(struct soap *soap, const char *tag, int id, struct ArrayOfDocumentFiles *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOfDocumentFiles);
	if (id < 0)
		return soap->error;
	return soap_out_ArrayOfDocumentFiles(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ArrayOfDocumentFiles ** SOAP_FMAC4 soap_get_PointerToArrayOfDocumentFiles(struct soap *soap, struct ArrayOfDocumentFiles **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfDocumentFiles(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ArrayOfDocumentFiles ** SOAP_FMAC4 soap_in_PointerToArrayOfDocumentFiles(struct soap *soap, const char *tag, struct ArrayOfDocumentFiles **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ArrayOfDocumentFiles **)soap_malloc(soap, sizeof(struct ArrayOfDocumentFiles *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ArrayOfDocumentFiles(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ArrayOfDocumentFiles **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfDocumentFiles, sizeof(struct ArrayOfDocumentFiles), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__DispatchReturnObject(struct soap *soap, struct ns1__DispatchReturnObject *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__DispatchReturnObject))
		soap_serialize_ns1__DispatchReturnObject(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__DispatchReturnObject(struct soap *soap, struct ns1__DispatchReturnObject *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__DispatchReturnObject);
	if (soap_out_PointerTons1__DispatchReturnObject(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__DispatchReturnObject(struct soap *soap, const char *tag, int id, struct ns1__DispatchReturnObject *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__DispatchReturnObject);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__DispatchReturnObject(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__DispatchReturnObject ** SOAP_FMAC4 soap_get_PointerTons1__DispatchReturnObject(struct soap *soap, struct ns1__DispatchReturnObject **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__DispatchReturnObject(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__DispatchReturnObject ** SOAP_FMAC4 soap_in_PointerTons1__DispatchReturnObject(struct soap *soap, const char *tag, struct ns1__DispatchReturnObject **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__DispatchReturnObject **)soap_malloc(soap, sizeof(struct ns1__DispatchReturnObject *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__DispatchReturnObject(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__DispatchReturnObject **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__DispatchReturnObject, sizeof(struct ns1__DispatchReturnObject), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__ShipmentPrice(struct soap *soap, struct ns1__ShipmentPrice **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__ShipmentPrice))
		soap_serialize_PointerTons1__ShipmentPrice(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__ShipmentPrice(struct soap *soap, struct ns1__ShipmentPrice **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__ShipmentPrice);
	if (soap_out_PointerToPointerTons1__ShipmentPrice(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__ShipmentPrice(struct soap *soap, const char *tag, int id, struct ns1__ShipmentPrice **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__ShipmentPrice);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__ShipmentPrice(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__ShipmentPrice *** SOAP_FMAC4 soap_get_PointerToPointerTons1__ShipmentPrice(struct soap *soap, struct ns1__ShipmentPrice ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__ShipmentPrice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__ShipmentPrice *** SOAP_FMAC4 soap_in_PointerToPointerTons1__ShipmentPrice(struct soap *soap, const char *tag, struct ns1__ShipmentPrice ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__ShipmentPrice ***)soap_malloc(soap, sizeof(struct ns1__ShipmentPrice **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__ShipmentPrice(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__ShipmentPrice ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__ShipmentPrice, sizeof(struct ns1__ShipmentPrice *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ShipmentPrice(struct soap *soap, struct ns1__ShipmentPrice *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ShipmentPrice))
		soap_serialize_ns1__ShipmentPrice(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ShipmentPrice(struct soap *soap, struct ns1__ShipmentPrice *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ShipmentPrice);
	if (soap_out_PointerTons1__ShipmentPrice(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ShipmentPrice(struct soap *soap, const char *tag, int id, struct ns1__ShipmentPrice *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ShipmentPrice);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__ShipmentPrice(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__ShipmentPrice ** SOAP_FMAC4 soap_get_PointerTons1__ShipmentPrice(struct soap *soap, struct ns1__ShipmentPrice **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ShipmentPrice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__ShipmentPrice ** SOAP_FMAC4 soap_in_PointerTons1__ShipmentPrice(struct soap *soap, const char *tag, struct ns1__ShipmentPrice **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__ShipmentPrice **)soap_malloc(soap, sizeof(struct ns1__ShipmentPrice *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__ShipmentPrice(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__ShipmentPrice **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ShipmentPrice, sizeof(struct ns1__ShipmentPrice), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__Sender(struct soap *soap, struct ns1__Sender **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__Sender))
		soap_serialize_PointerTons1__Sender(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__Sender(struct soap *soap, struct ns1__Sender **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__Sender);
	if (soap_out_PointerToPointerTons1__Sender(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__Sender(struct soap *soap, const char *tag, int id, struct ns1__Sender **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__Sender);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__Sender(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__Sender *** SOAP_FMAC4 soap_get_PointerToPointerTons1__Sender(struct soap *soap, struct ns1__Sender ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__Sender(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__Sender *** SOAP_FMAC4 soap_in_PointerToPointerTons1__Sender(struct soap *soap, const char *tag, struct ns1__Sender ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__Sender ***)soap_malloc(soap, sizeof(struct ns1__Sender **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__Sender(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__Sender ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__Sender, sizeof(struct ns1__Sender *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Sender(struct soap *soap, struct ns1__Sender *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Sender))
		soap_serialize_ns1__Sender(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Sender(struct soap *soap, struct ns1__Sender *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__Sender);
	if (soap_out_PointerTons1__Sender(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Sender(struct soap *soap, const char *tag, int id, struct ns1__Sender *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Sender);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__Sender(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__Sender ** SOAP_FMAC4 soap_get_PointerTons1__Sender(struct soap *soap, struct ns1__Sender **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Sender(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__Sender ** SOAP_FMAC4 soap_in_PointerTons1__Sender(struct soap *soap, const char *tag, struct ns1__Sender **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__Sender **)soap_malloc(soap, sizeof(struct ns1__Sender *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__Sender(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__Sender **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Sender, sizeof(struct ns1__Sender), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__ConfigProfile(struct soap *soap, struct ns1__ConfigProfile **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__ConfigProfile))
		soap_serialize_PointerTons1__ConfigProfile(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__ConfigProfile(struct soap *soap, struct ns1__ConfigProfile **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__ConfigProfile);
	if (soap_out_PointerToPointerTons1__ConfigProfile(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__ConfigProfile(struct soap *soap, const char *tag, int id, struct ns1__ConfigProfile **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__ConfigProfile);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__ConfigProfile(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__ConfigProfile *** SOAP_FMAC4 soap_get_PointerToPointerTons1__ConfigProfile(struct soap *soap, struct ns1__ConfigProfile ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__ConfigProfile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__ConfigProfile *** SOAP_FMAC4 soap_in_PointerToPointerTons1__ConfigProfile(struct soap *soap, const char *tag, struct ns1__ConfigProfile ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__ConfigProfile ***)soap_malloc(soap, sizeof(struct ns1__ConfigProfile **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__ConfigProfile(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__ConfigProfile ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__ConfigProfile, sizeof(struct ns1__ConfigProfile *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ConfigProfile(struct soap *soap, struct ns1__ConfigProfile *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ConfigProfile))
		soap_serialize_ns1__ConfigProfile(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ConfigProfile(struct soap *soap, struct ns1__ConfigProfile *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ConfigProfile);
	if (soap_out_PointerTons1__ConfigProfile(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ConfigProfile(struct soap *soap, const char *tag, int id, struct ns1__ConfigProfile *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ConfigProfile);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__ConfigProfile(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__ConfigProfile ** SOAP_FMAC4 soap_get_PointerTons1__ConfigProfile(struct soap *soap, struct ns1__ConfigProfile **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ConfigProfile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__ConfigProfile ** SOAP_FMAC4 soap_in_PointerTons1__ConfigProfile(struct soap *soap, const char *tag, struct ns1__ConfigProfile **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__ConfigProfile **)soap_malloc(soap, sizeof(struct ns1__ConfigProfile *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__ConfigProfile(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__ConfigProfile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ConfigProfile, sizeof(struct ns1__ConfigProfile), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostring(struct soap *soap, char **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_string))
		soap_serialize_string(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostring(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostring);
	if (soap_out_PointerTostring(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostring(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_string);
	if (id < 0)
		return soap->error;
	return soap_out_string(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTostring(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerTostring(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_string, sizeof(char *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__Shipment(struct soap *soap, struct ns1__Shipment **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__Shipment))
		soap_serialize_PointerTons1__Shipment(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__Shipment(struct soap *soap, struct ns1__Shipment **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__Shipment);
	if (soap_out_PointerToPointerTons1__Shipment(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__Shipment(struct soap *soap, const char *tag, int id, struct ns1__Shipment **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__Shipment);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__Shipment(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__Shipment *** SOAP_FMAC4 soap_get_PointerToPointerTons1__Shipment(struct soap *soap, struct ns1__Shipment ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__Shipment(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__Shipment *** SOAP_FMAC4 soap_in_PointerToPointerTons1__Shipment(struct soap *soap, const char *tag, struct ns1__Shipment ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__Shipment ***)soap_malloc(soap, sizeof(struct ns1__Shipment **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__Shipment(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__Shipment ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__Shipment, sizeof(struct ns1__Shipment *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Shipment(struct soap *soap, struct ns1__Shipment *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Shipment))
		soap_serialize_ns1__Shipment(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Shipment(struct soap *soap, struct ns1__Shipment *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__Shipment);
	if (soap_out_PointerTons1__Shipment(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Shipment(struct soap *soap, const char *tag, int id, struct ns1__Shipment *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Shipment);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__Shipment(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__Shipment ** SOAP_FMAC4 soap_get_PointerTons1__Shipment(struct soap *soap, struct ns1__Shipment **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Shipment(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__Shipment ** SOAP_FMAC4 soap_in_PointerTons1__Shipment(struct soap *soap, const char *tag, struct ns1__Shipment **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__Shipment **)soap_malloc(soap, sizeof(struct ns1__Shipment *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__Shipment(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__Shipment **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Shipment, sizeof(struct ns1__Shipment), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__Option(struct soap *soap, struct ns1__Option **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__Option))
		soap_serialize_PointerTons1__Option(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__Option(struct soap *soap, struct ns1__Option **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__Option);
	if (soap_out_PointerToPointerTons1__Option(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__Option(struct soap *soap, const char *tag, int id, struct ns1__Option **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__Option);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__Option(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__Option *** SOAP_FMAC4 soap_get_PointerToPointerTons1__Option(struct soap *soap, struct ns1__Option ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__Option(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__Option *** SOAP_FMAC4 soap_in_PointerToPointerTons1__Option(struct soap *soap, const char *tag, struct ns1__Option ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__Option ***)soap_malloc(soap, sizeof(struct ns1__Option **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__Option(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__Option ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__Option, sizeof(struct ns1__Option *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Option(struct soap *soap, struct ns1__Option *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Option))
		soap_serialize_ns1__Option(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Option(struct soap *soap, struct ns1__Option *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__Option);
	if (soap_out_PointerTons1__Option(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Option(struct soap *soap, const char *tag, int id, struct ns1__Option *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Option);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__Option(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__Option ** SOAP_FMAC4 soap_get_PointerTons1__Option(struct soap *soap, struct ns1__Option **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Option(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__Option ** SOAP_FMAC4 soap_in_PointerTons1__Option(struct soap *soap, const char *tag, struct ns1__Option **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__Option **)soap_malloc(soap, sizeof(struct ns1__Option *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__Option(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__Option **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Option, sizeof(struct ns1__Option), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__Recipient(struct soap *soap, struct ns1__Recipient **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__Recipient))
		soap_serialize_PointerTons1__Recipient(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__Recipient(struct soap *soap, struct ns1__Recipient **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__Recipient);
	if (soap_out_PointerToPointerTons1__Recipient(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__Recipient(struct soap *soap, const char *tag, int id, struct ns1__Recipient **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__Recipient);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__Recipient(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__Recipient *** SOAP_FMAC4 soap_get_PointerToPointerTons1__Recipient(struct soap *soap, struct ns1__Recipient ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__Recipient(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__Recipient *** SOAP_FMAC4 soap_in_PointerToPointerTons1__Recipient(struct soap *soap, const char *tag, struct ns1__Recipient ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__Recipient ***)soap_malloc(soap, sizeof(struct ns1__Recipient **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__Recipient(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__Recipient ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__Recipient, sizeof(struct ns1__Recipient *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Recipient(struct soap *soap, struct ns1__Recipient *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Recipient))
		soap_serialize_ns1__Recipient(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Recipient(struct soap *soap, struct ns1__Recipient *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__Recipient);
	if (soap_out_PointerTons1__Recipient(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Recipient(struct soap *soap, const char *tag, int id, struct ns1__Recipient *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Recipient);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__Recipient(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__Recipient ** SOAP_FMAC4 soap_get_PointerTons1__Recipient(struct soap *soap, struct ns1__Recipient **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Recipient(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__Recipient ** SOAP_FMAC4 soap_in_PointerTons1__Recipient(struct soap *soap, const char *tag, struct ns1__Recipient **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__Recipient **)soap_malloc(soap, sizeof(struct ns1__Recipient *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__Recipient(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__Recipient **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Recipient, sizeof(struct ns1__Recipient), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__DocumentFile(struct soap *soap, struct ns1__DocumentFile **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__DocumentFile))
		soap_serialize_PointerTons1__DocumentFile(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__DocumentFile(struct soap *soap, struct ns1__DocumentFile **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__DocumentFile);
	if (soap_out_PointerToPointerTons1__DocumentFile(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__DocumentFile(struct soap *soap, const char *tag, int id, struct ns1__DocumentFile **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__DocumentFile);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__DocumentFile(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__DocumentFile *** SOAP_FMAC4 soap_get_PointerToPointerTons1__DocumentFile(struct soap *soap, struct ns1__DocumentFile ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__DocumentFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__DocumentFile *** SOAP_FMAC4 soap_in_PointerToPointerTons1__DocumentFile(struct soap *soap, const char *tag, struct ns1__DocumentFile ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__DocumentFile ***)soap_malloc(soap, sizeof(struct ns1__DocumentFile **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__DocumentFile(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__DocumentFile ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__DocumentFile, sizeof(struct ns1__DocumentFile *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__DocumentFile(struct soap *soap, struct ns1__DocumentFile *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__DocumentFile))
		soap_serialize_ns1__DocumentFile(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__DocumentFile(struct soap *soap, struct ns1__DocumentFile *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__DocumentFile);
	if (soap_out_PointerTons1__DocumentFile(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__DocumentFile(struct soap *soap, const char *tag, int id, struct ns1__DocumentFile *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__DocumentFile);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__DocumentFile(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__DocumentFile ** SOAP_FMAC4 soap_get_PointerTons1__DocumentFile(struct soap *soap, struct ns1__DocumentFile **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__DocumentFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__DocumentFile ** SOAP_FMAC4 soap_in_PointerTons1__DocumentFile(struct soap *soap, const char *tag, struct ns1__DocumentFile **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__DocumentFile **)soap_malloc(soap, sizeof(struct ns1__DocumentFile *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__DocumentFile(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__DocumentFile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__DocumentFile, sizeof(struct ns1__DocumentFile), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfShipmentsPrice(struct soap *soap, struct ArrayOfShipmentsPrice *const*a)
{
	if (*a)
		soap_serialize_ArrayOfShipmentsPrice(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfShipmentsPrice(struct soap *soap, struct ArrayOfShipmentsPrice *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfShipmentsPrice);
	if (soap_out_PointerToArrayOfShipmentsPrice(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfShipmentsPrice(struct soap *soap, const char *tag, int id, struct ArrayOfShipmentsPrice *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOfShipmentsPrice);
	if (id < 0)
		return soap->error;
	return soap_out_ArrayOfShipmentsPrice(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ArrayOfShipmentsPrice ** SOAP_FMAC4 soap_get_PointerToArrayOfShipmentsPrice(struct soap *soap, struct ArrayOfShipmentsPrice **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfShipmentsPrice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ArrayOfShipmentsPrice ** SOAP_FMAC4 soap_in_PointerToArrayOfShipmentsPrice(struct soap *soap, const char *tag, struct ArrayOfShipmentsPrice **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ArrayOfShipmentsPrice **)soap_malloc(soap, sizeof(struct ArrayOfShipmentsPrice *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ArrayOfShipmentsPrice(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ArrayOfShipmentsPrice **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfShipmentsPrice, sizeof(struct ArrayOfShipmentsPrice), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfSenders(struct soap *soap, struct ArrayOfSenders *const*a)
{
	if (*a)
		soap_serialize_ArrayOfSenders(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfSenders(struct soap *soap, struct ArrayOfSenders *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfSenders);
	if (soap_out_PointerToArrayOfSenders(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfSenders(struct soap *soap, const char *tag, int id, struct ArrayOfSenders *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOfSenders);
	if (id < 0)
		return soap->error;
	return soap_out_ArrayOfSenders(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ArrayOfSenders ** SOAP_FMAC4 soap_get_PointerToArrayOfSenders(struct soap *soap, struct ArrayOfSenders **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfSenders(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ArrayOfSenders ** SOAP_FMAC4 soap_in_PointerToArrayOfSenders(struct soap *soap, const char *tag, struct ArrayOfSenders **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ArrayOfSenders **)soap_malloc(soap, sizeof(struct ArrayOfSenders *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ArrayOfSenders(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ArrayOfSenders **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfSenders, sizeof(struct ArrayOfSenders), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfConfigProfiles(struct soap *soap, struct ArrayOfConfigProfiles *const*a)
{
	if (*a)
		soap_serialize_ArrayOfConfigProfiles(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfConfigProfiles(struct soap *soap, struct ArrayOfConfigProfiles *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfConfigProfiles);
	if (soap_out_PointerToArrayOfConfigProfiles(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfConfigProfiles(struct soap *soap, const char *tag, int id, struct ArrayOfConfigProfiles *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOfConfigProfiles);
	if (id < 0)
		return soap->error;
	return soap_out_ArrayOfConfigProfiles(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ArrayOfConfigProfiles ** SOAP_FMAC4 soap_get_PointerToArrayOfConfigProfiles(struct soap *soap, struct ArrayOfConfigProfiles **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfConfigProfiles(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ArrayOfConfigProfiles ** SOAP_FMAC4 soap_in_PointerToArrayOfConfigProfiles(struct soap *soap, const char *tag, struct ArrayOfConfigProfiles **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ArrayOfConfigProfiles **)soap_malloc(soap, sizeof(struct ArrayOfConfigProfiles *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ArrayOfConfigProfiles(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ArrayOfConfigProfiles **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfConfigProfiles, sizeof(struct ArrayOfConfigProfiles), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfShipments(struct soap *soap, struct ArrayOfShipments *const*a)
{
	if (*a)
		soap_serialize_ArrayOfShipments(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfShipments(struct soap *soap, struct ArrayOfShipments *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfShipments);
	if (soap_out_PointerToArrayOfShipments(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfShipments(struct soap *soap, const char *tag, int id, struct ArrayOfShipments *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOfShipments);
	if (id < 0)
		return soap->error;
	return soap_out_ArrayOfShipments(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ArrayOfShipments ** SOAP_FMAC4 soap_get_PointerToArrayOfShipments(struct soap *soap, struct ArrayOfShipments **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfShipments(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ArrayOfShipments ** SOAP_FMAC4 soap_in_PointerToArrayOfShipments(struct soap *soap, const char *tag, struct ArrayOfShipments **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ArrayOfShipments **)soap_malloc(soap, sizeof(struct ArrayOfShipments *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ArrayOfShipments(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ArrayOfShipments **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfShipments, sizeof(struct ArrayOfShipments), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofloat(struct soap *soap, float *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_float);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofloat(struct soap *soap, float *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofloat);
	if (soap_out_PointerTofloat(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofloat(struct soap *soap, const char *tag, int id, float *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_float);
	if (id < 0)
		return soap->error;
	return soap_out_float(soap, tag, id, *a, type);
}

SOAP_FMAC3 float ** SOAP_FMAC4 soap_get_PointerTofloat(struct soap *soap, float **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofloat(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 float ** SOAP_FMAC4 soap_in_PointerTofloat(struct soap *soap, const char *tag, float **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (float **)soap_malloc(soap, sizeof(float *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_float(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (float **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_float, sizeof(float), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToint(struct soap *soap, int *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToint(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToint);
	if (soap_out_PointerToint(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToint(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_int);
	if (id < 0)
		return soap->error;
	return soap_out_int(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerToint(struct soap *soap, int **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_in_PointerToint(struct soap *soap, const char *tag, int **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_int(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_int, sizeof(int), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, -1, -1);
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, -1, -1);
	return p;
}

#ifdef __cplusplus
}
#endif

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.c */
